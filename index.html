<!-- index.html
========================================================
VMQ index.html (Drop-in replacement) â€” v3.0.6
Fixes (without removing features):
- âœ… Deterministic CSS cascade (base â†’ themes â†’ components â†’ animations)
- âœ… Never blank: shell stays until vmq-app-mounted OR timeout
- âœ… GH Pages safe: robust base-path from import.meta.url
- âœ… SW registration guarded + scope correct
- âœ… Diagnostic overlay + global error capture
- âœ… NEW: No-devtools fatal box shows failing import URL on timeout/import fail
========================================================
-->
<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#3b82f6" />
  <meta name="color-scheme" content="light dark" />

  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://unpkg.com 'unsafe-inline';
          style-src 'self' 'unsafe-inline';
          connect-src 'self' https://unpkg.com;
          img-src 'self' data:;
          font-src 'self';
          media-src 'self';
          object-src 'none';
          base-uri 'self';
          frame-ancestors 'none';
        " />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="Violin Mastery Quest" />
  <meta name="application-name" content="VMQ" />

  <meta name="description" content="Violin Mastery Quest v3 â€” adaptive violin training: intervals, fingerboard, scales, rhythm, SM-2, AI coach." />
  <title>Violin Mastery Quest</title>

  <meta property="og:title" content="Violin Mastery Quest" />
  <meta property="og:description" content="Adaptive violin training: Bieler Method + spaced repetition + AI coach" />
  <meta property="og:image" content="./icons/icon-512.png" />
  <meta property="og:type" content="website" />

  <link rel="manifest" href="./manifest.json" />

  <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-32.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png" />

  <link rel="preconnect" href="https://unpkg.com" crossorigin />
  <link rel="dns-prefetch" href="https://unpkg.com" />

  <link rel="modulepreload" href="./js/App.js" />
  <link rel="modulepreload" href="./js/config/routeManifest.js" />

  <!-- CSS (deterministic order) -->
  <link rel="stylesheet" href="./css/base.css" />

  <link rel="preload" href="./css/themes.css" as="style" />
  <link rel="preload" href="./css/components.css" as="style" />
  <link rel="preload" href="./css/animations.css" as="style" />

  <link rel="stylesheet" href="./css/themes.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/components.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/animations.css" media="print" onload="this.media='all'">

  <noscript>
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/components.css">
    <link rel="stylesheet" href="./css/animations.css">
  </noscript>

  <style>
    :root { --primary-rgb: 59 130 246; }
  </style>
</head>

<body>
  <!-- Shell UI (stays until React confirms mount) -->
  <div class="loading-screen active" id="loading-screen" aria-live="polite">
    <div class="loading-spinner"></div>
    <div class="loading-content">
      <h1 class="loading-title">Violin Mastery Quest</h1>
      <p class="loading-subtitle">Adaptive modules â€¢ Offline-ready</p>

      <div class="loading-progress">
        <div class="progress-bar">
          <div class="progress-fill" id="loading-progress-fill" style="--width: 0%"></div>
        </div>
      </div>

      <p class="loading-status" id="loading-status">Initializingâ€¦</p>
      <div class="engine-status" id="engine-status" aria-live="polite"></div>
    </div>
  </div>

  <div class="toast-container" id="toast-container"></div>

  <div class="diagnostic-overlay" id="diagnostic-overlay" style="display:none;">
    <div class="diagnostic-content">
      <h2>ðŸ”§ VMQ Diagnostic Mode</h2>
      <pre id="diagnostic-log" style="white-space:pre-wrap;"></pre>
      <button id="diagnostic-reload" class="btn btn-primary" type="button">Reload App</button>
    </div>
  </div>

  <div id="root"></div>

  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Single owner module: listeners â†’ app import â†’ bootstrap â†’ wait mount -->
  <script type="module">
    // ------------------------------------------------------------
    // Base-path derived from the directory serving THIS index.html
    // ------------------------------------------------------------
    const BASE_URL  = new URL('./', import.meta.url);
    const BASE_PATH = BASE_URL.pathname; // e.g. "/violin-mastery-quest/" or "/"
    window.__VMQ_BASE_PATH__ = BASE_PATH;

    const startTime = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    window.vmqMetrics = window.vmqMetrics || { loadTime: 0, engineInitTime: 0, mlWarmupTime: 0 };

    const isDiagnosticMode =
      window.location.search.includes('vmq-diagnostics') ||
      window.location.search.includes('debug=true');

    const diagnosticLog = [];
    function logDiagnostic(category, message, data = null) {
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const timestamp = (now - startTime).toFixed(2);
      const line = `[${timestamp}ms] [${category}] ${message}${data ? ' ' + JSON.stringify(data) : ''}`;
      diagnosticLog.push(line);

      if (isDiagnosticMode) {
        console.log(`%cVMQ Diagnostics: ${line}`, 'color:#3b82f6;font-weight:bold;');
        const logEl = document.getElementById('diagnostic-log');
        if (logEl) logEl.textContent = diagnosticLog.join('\n');
      }
    }

    function showDiagnosticOverlay(extraError = null) {
      const overlay = document.getElementById('diagnostic-overlay');
      if (!overlay || !isDiagnosticMode) return;

      overlay.style.display = 'flex';
      const logEl = document.getElementById('diagnostic-log');
      if (logEl) {
        logEl.textContent =
          diagnosticLog.join('\n') +
          (extraError ? `\n\n${extraError?.stack || String(extraError)}` : '');
      }
    }

    document.getElementById('diagnostic-reload')?.addEventListener('click', () => window.location.reload());

    function setLoadingStatus(text) {
      const el = document.getElementById('loading-status');
      if (el) el.textContent = text;
    }
    function setProgress(percent) {
      const fill = document.getElementById('loading-progress-fill');
      if (fill) fill.style.setProperty('--width', `${Math.max(0, Math.min(100, percent))}%`);
    }

    // ------------------------------------------------------------
    // NO-DEVTOOLS FATAL BOX (must exist BEFORE any errors/imports)
    // ------------------------------------------------------------
    function extractUrl(text) {
      const s = String(text || '');
      const m =
        s.match(/https?:\/\/[^\s'"]+/) ||
        s.match(/(?:\.\/|\/)js\/[^\s'"]+\.js(?:\?[^\s'"]+)?/);
      return m ? m[0] : null;
    }

    function showBootFatal(title, info = {}) {
      const host = document.querySelector('#loading-screen .loading-content') || document.getElementById('loading-screen');
      if (!host) return;

      let box = document.getElementById('vmq-fatal-box');
      if (!box) {
        box = document.createElement('div');
        box.id = 'vmq-fatal-box';
        box.style.cssText =
          'margin-top:12px;padding:12px;border:1px solid rgba(239,68,68,.65);' +
          'background:rgba(239,68,68,.08);border-radius:12px;text-align:left;' +
          'max-width:520px;word-break:break-word;font-family:ui-monospace,Menlo,monospace;font-size:12px;';
        host.appendChild(box);
      }

      const sw =
        ('serviceWorker' in navigator)
          ? (navigator.serviceWorker.controller ? 'controlling' : 'not controlling')
          : 'unsupported';

      const basePath = window.__VMQ_BASE_PATH__ || '(unknown)';
      const appUrl = window.__VMQ_APP_URL__ || '(unknown)';
      const msg = info.message || '';
      const url =
        info.failingUrl ||
        extractUrl(msg) ||
        extractUrl(info.stack) ||
        extractUrl(info.reason) ||
        '(not found)';

      box.innerHTML =
        `<div style="font-weight:800;margin-bottom:6px;">ðŸš¨ ${title}</div>` +
        `<div><b>Failing URL:</b> ${url}</div>` +
        `<div><b>App URL:</b> ${appUrl}</div>` +
        `<div><b>Base path:</b> ${basePath}</div>` +
        `<div><b>SW:</b> ${sw}</div>` +
        (msg ? `<div style="margin-top:6px;"><b>Message:</b> ${msg}</div>` : '') +
        (info.stack ? `<div style="margin-top:6px;white-space:pre-wrap;"><b>Stack:</b>\n${info.stack}</div>` : '');
    }

    window.__VMQ_LAST_ERROR__ = null;

    // Global error capture
    window.addEventListener('error', (event) => {
      logDiagnostic('ERROR', event.message, { filename: event.filename, lineno: event.lineno, colno: event.colno });
      window.__VMQ_LAST_ERROR__ = {
        message: event.message,
        stack: event?.error?.stack || '',
        failingUrl: event.filename || extractUrl(event.message) || null
      };
      showDiagnosticOverlay(event.error || event);
    });

    window.addEventListener('unhandledrejection', (event) => {
      const reason = event?.reason;
      logDiagnostic('PROMISE', reason?.message || 'Unhandled rejection', reason ? { reason: String(reason) } : null);
      window.__VMQ_LAST_ERROR__ = {
        message: reason?.message || String(reason),
        stack: reason?.stack || '',
        failingUrl: extractUrl(reason?.message) || extractUrl(String(reason)) || null
      };
      if (isDiagnosticMode) showDiagnosticOverlay(reason);
    });

    // App import failure event (from our loader below)
    window.addEventListener('vmq-app-import-failed', (e) => {
      const detail = e?.detail || {};
      logDiagnostic('APP', 'App module failed to import', { appUrl: detail.appUrl, message: detail.message });
      showBootFatal('App module failed to import', {
        message: detail.message,
        stack: detail.stack,
        failingUrl: extractUrl(detail.message) || extractUrl(detail.stack) || null
      });
    });

    // ------------------------------------------------------------
    // Fail-open feature gating (compatible with App.js checkFeature)
    // ------------------------------------------------------------
    function checkFeature(featureName) {
      try {
        const features = window.VMQ?.FEATURES || window.VMQ?.features || {};
        return features?.[featureName]?.enabled !== false;
      } catch {
        return true;
      }
    }

    // ------------------------------------------------------------
    // Start App import ASAP (after React UMD is available)
    // ------------------------------------------------------------
    {
      const appUrl = new URL('./js/App.js', BASE_URL).href;
      window.__VMQ_APP_URL__ = appUrl;

      import(appUrl).catch((err) => {
        const detail = {
          appUrl,
          message: err?.message || String(err),
          stack: err?.stack || '',
          when: new Date().toISOString()
        };
        window.__VMQ_APP_IMPORT_ERROR__ = detail;
        window.dispatchEvent(new CustomEvent('vmq-app-import-failed', { detail }));
      });
    }

    // ------------------------------------------------------------
    // Optional imports (MUST NOT hard-crash bootstrap)
    // ------------------------------------------------------------
    let ROUTE_TO_COMPONENT_FILE = Object.create(null);
    let normalizeRouteSlug = (s) => (s || '').toString().trim().toLowerCase();

    async function tryLoadRouteManifest() {
      try {
        const mod = await import(new URL('./js/config/routeManifest.js', BASE_URL).href);
        if (mod?.ROUTE_TO_COMPONENT_FILE) ROUTE_TO_COMPONENT_FILE = mod.ROUTE_TO_COMPONENT_FILE;
        if (typeof mod?.normalizeRouteSlug === 'function') normalizeRouteSlug = mod.normalizeRouteSlug;
        logDiagnostic('MANIFEST', 'routeManifest loaded');
      } catch (e) {
        logDiagnostic('MANIFEST', 'routeManifest missing/unavailable (continuing)', { err: String(e?.message || e) });
      }
    }

    // Engine health (degraded supported)
    const requiredEngines = [
      { name: 'audioEngine',       critical: true  },
      { name: 'gamification',      critical: true  },
      { name: 'sessionTracker',    critical: true  },
      { name: 'spacedRepetition',  critical: false },
      { name: 'analytics',         critical: false },
      { name: 'difficultyAdapter', critical: false }
    ];

    async function checkEngineHealth() {
      const statusEl = document.getElementById('engine-status');
      const status = {};
      let allCriticalOk = true;

      for (const e of requiredEngines) {
        try {
          const modUrl = new URL(`./js/engines/${e.name}.js`, BASE_URL).href;
          const mod = await import(modUrl);
          const ok = !!(mod && (mod.default || mod[e.name] || Object.keys(mod).length));
          status[e.name] = ok ? 'âœ…' : 'âŒ';
          if (!ok && e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: ${ok ? 'healthy' : 'failed'}`, { critical: e.critical });
        } catch (err) {
          status[e.name] = 'âŒ';
          if (e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: failed to load`, { critical: e.critical, err: String(err?.message || err) });
        }
      }

      if (statusEl) {
        statusEl.innerHTML = Object.entries(status)
          .map(([name, icon]) => `<span class="engine-indicator">${icon} ${name}</span>`)
          .join('');
      }

      return allCriticalOk;
    }

    // ML warmup (best-effort)
    async function warmupMLModels() {
      const wantAnalytics = checkFeature('analytics');
      const wantDA = checkFeature('difficultyAdapter');
      if (!wantAnalytics && !wantDA) return;

      const mlStart = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      logDiagnostic('ML', 'Warming upâ€¦');

      try {
        const analyticsUrl  = new URL('./js/engines/analytics.js', BASE_URL).href;
        const difficultyUrl = new URL('./js/engines/difficultyAdapter.js', BASE_URL).href;

        const [analyticsMod, difficultyMod] = await Promise.allSettled([
          import(analyticsUrl),
          import(difficultyUrl)
        ]);

        if (analyticsMod.status === 'fulfilled' && typeof analyticsMod.value?.generateMLRecommendations === 'function') {
          await analyticsMod.value.generateMLRecommendations().catch(() => {});
          logDiagnostic('ML', 'Analytics warm');
        }

        if (difficultyMod.status === 'fulfilled' && typeof difficultyMod.value?.getAdaptiveConfig === 'function') {
          await difficultyMod.value.getAdaptiveConfig().catch(() => {});
          logDiagnostic('ML', 'Difficulty warm');
        }
      } catch (e) {
        logDiagnostic('ML', 'Warmup failed', { err: String(e?.message || e) });
      }

      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      window.vmqMetrics.mlWarmupTime = Math.round(now - mlStart);
      logDiagnostic('ML', `Warmup complete: ${window.vmqMetrics.mlWarmupTime}ms`);
    }

    // Prefetch (safe)
    function modulePreload(href) {
      if (!href) return;
      if (document.head.querySelector(`link[rel="modulepreload"][href="${href}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'modulepreload';
      link.href = href;
      document.head.appendChild(link);
    }

    function resolveComponentHref(routeOrId) {
      if (!routeOrId) return null;
      const raw = String(routeOrId).replace(/^#/, '').split('?')[0].trim();
      if (!raw) return null;
      const key = normalizeRouteSlug(raw);
      const file = ROUTE_TO_COMPONENT_FILE?.[key];
      return file ? new URL(`./js/components/${file}`, BASE_URL).href : null;
    }

    async function prefetchUserModules() {
      let level = 'beginner';
      try {
        const raw = localStorage.getItem('vmq-profile') || localStorage.getItem('vmq.profile');
        const profile = raw ? JSON.parse(raw) : null;
        if (profile?.level) level = profile.level;
      } catch {}

      const modulesToPrefetch = {
        beginner:      ['intervals', 'keys', 'rhythm'],
        intermediate:  ['bieler', 'scales', 'fingerboard'],
        advanced:      ['bieler', 'scales', 'flashcards']
      };

      const list = modulesToPrefetch[level] || modulesToPrefetch.beginner;
      list.forEach((id) => modulePreload(resolveComponentHref(id)));
      logDiagnostic('PREFETCH', `modulepreload(${level})`, list);
    }

    // Service Worker registration (single owner, scope-correct)
    async function registerServiceWorker() {
      if (window.__VMQ_SW_REGISTERED__) {
        logDiagnostic('SW', 'Already registered (guard flag set)');
        return;
      }
      if (!checkFeature('pwaOffline') || !('serviceWorker' in navigator)) {
        logDiagnostic('SW', 'Disabled or unsupported');
        return;
      }

      try {
        // getRegistration() expects a scope URL/string; BASE_PATH is correct for GH Pages subpath
        const existing = await navigator.serviceWorker.getRegistration(BASE_PATH);
        let registration = existing;

        if (!registration) {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = 'index.html';

          const swUrl = new URL('./sw.js', BASE_URL).href;
          registration = await navigator.serviceWorker.register(swUrl, {
            scope: BASE_PATH,
            updateViaCache: 'none'
          });
          logDiagnostic('SW', `Registered`, { scope: registration.scope });
        } else {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = window.__VMQ_SW_OWNER__ || 'existing';
          logDiagnostic('SW', `Using existing registration`, { scope: registration.scope });
        }

        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              logDiagnostic('SW', 'Update available');
              window.dispatchEvent(new CustomEvent('vmq-update-available', {
                detail: { version: '3.0.6', cacheBust: Date.now() }
              }));
            }
          });
        });

        await navigator.serviceWorker.ready.then(async (reg) => {
          if (reg.sync) {
            try { await reg.sync.register('sync-analytics'); logDiagnostic('SYNC', 'sync-analytics registered'); } catch {}
            try { await reg.sync.register('sync-sm2');       logDiagnostic('SYNC', 'sync-sm2 registered'); } catch {}
          }
          if (reg.periodicSync) {
            try {
              await reg.periodicSync.register('check-due-items', { minInterval: 30 * 60 * 1000 });
              logDiagnostic('SYNC', 'periodicSync: check-due-items registered');
            } catch {}
          }
        }).catch(() => {});
      } catch (err) {
        window.__VMQ_SW_REGISTERED__ = false;
        logDiagnostic('SW', 'Registration failed', { err: String(err?.message || err) });
      }
    }

    // Keep shell visible until React confirms mount
    function waitForReactMount({ timeoutMs = 12000 } = {}) {
      return new Promise((resolve) => {
        let done = false;

        const finish = (why) => {
          if (done) return;
          done = true;
          resolve(why);
        };

        const onMounted = () => finish('vmq-app-mounted');
        window.addEventListener('vmq-app-mounted', onMounted, { once: true });

        setTimeout(() => finish('timeout'), timeoutMs);
      });
    }

    // Bootstrap sequence
    async function bootstrap() {
      setProgress(10);
      setLoadingStatus('Preparingâ€¦');

      await tryLoadRouteManifest();
      setProgress(20);

      setLoadingStatus('Warming upâ€¦');
      await warmupMLModels();
      setProgress(40);

      setLoadingStatus('Checking enginesâ€¦');
      const criticalOk = await checkEngineHealth();
      if (!criticalOk) setLoadingStatus('Some features unavailable, continuingâ€¦');
      setProgress(60);

      setLoadingStatus('Prefetchingâ€¦');
      await prefetchUserModules();
      setProgress(75);

      setLoadingStatus('Enabling offlineâ€¦');
      await registerServiceWorker();
      setProgress(90);

      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      window.vmqMetrics.engineInitTime = Math.round(now - startTime);
      setProgress(100);
      logDiagnostic('BOOTSTRAP', 'Complete', window.vmqMetrics);
    }

    // Run bootstrap and then wait for React to confirm mount before hiding shell
    bootstrap().then(async () => {
      const why = await waitForReactMount({ timeoutMs: 12000 });

      if (why === 'timeout') {
        logDiagnostic('BOOTSTRAP', 'React mount timeout (shell retained)');
        setLoadingStatus('Still loadingâ€¦ If stuck, enable ?vmq-diagnostics');
        showBootFatal(
          'Mount timeout (React never mounted)',
          window.__VMQ_APP_IMPORT_ERROR__ || window.__VMQ_LAST_ERROR__ || {}
        );
        if (isDiagnosticMode) showDiagnosticOverlay(null);
        return;
      }

      // React confirmed mount
      document.getElementById('loading-screen')?.classList.remove('active');
      window.dispatchEvent(new CustomEvent('vmq-ready', { detail: { metrics: window.vmqMetrics, diagnosticLog } }));
    }).catch((err) => {
      logDiagnostic('BOOTSTRAP', 'Fatal error', { err: String(err?.message || err) });
      showDiagnosticOverlay(err);
      setLoadingStatus('Error loading VMQ. Enable diagnostics for details.');
      showBootFatal('Fatal bootstrap error', { message: err?.message || String(err), stack: err?.stack || '' });
    });
  </script>
</body>
</html>