<!-- index.html
========================================================
VMQ index.html (Drop-in replacement) â€” v3.0.4+
Fixes (without removing features):
- âœ… Deterministic CSS cascade (base â†’ themes â†’ components â†’ animations)
- âœ… Prevents â€œflash then blankâ€: NEVER hides shell until React signals vmq-app-mounted OR a timeout
- âœ… Robust base-path (no hardcoded repo name): computed from import.meta.url directory
- âœ… SW registration is single-owner guarded and scope-correct for GH Pages OR root hosting
- âœ… Diagnostics overlay for script/module failures and unhandled rejections
========================================================
-->
<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#3b82f6" />
  <meta name="color-scheme" content="light dark" />

  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://unpkg.com 'unsafe-inline';
          style-src 'self' 'unsafe-inline';
          connect-src 'self' https://unpkg.com;
          img-src 'self' data:;
          font-src 'self';
          media-src 'self';
          object-src 'none';
          base-uri 'self';
          frame-ancestors 'none';
        " />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="Violin Mastery Quest" />
  <meta name="application-name" content="VMQ" />

  <meta name="description" content="Violin Mastery Quest v3 â€” adaptive violin training: intervals, fingerboard, scales, rhythm, SM-2, AI coach." />
  <title>Violin Mastery Quest</title>

  <meta property="og:title" content="Violin Mastery Quest" />
  <meta property="og:description" content="Adaptive violin training: Bieler Method + spaced repetition + AI coach" />
  <meta property="og:image" content="./icons/icon-512.png" />
  <meta property="og:type" content="website" />

  <link rel="manifest" href="./manifest.json" />

  <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-32.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png" />

  <link rel="preconnect" href="https://unpkg.com" crossorigin />
  <link rel="dns-prefetch" href="https://unpkg.com" />

  <link rel="modulepreload" href="./js/App.js" />
  <link rel="modulepreload" href="./js/config/routeManifest.js" />

  <!-- CSS (deterministic order) -->
  <link rel="stylesheet" href="./css/base.css" />

  <link rel="preload" href="./css/themes.css" as="style" />
  <link rel="preload" href="./css/components.css" as="style" />
  <link rel="preload" href="./css/animations.css" as="style" />

  <link rel="stylesheet" href="./css/themes.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/components.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/animations.css" media="print" onload="this.media='all'">

  <noscript>
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/components.css">
    <link rel="stylesheet" href="./css/animations.css">
  </noscript>

  <style>
    :root { --primary-rgb: 59 130 246; }
  </style>
</head>

<body>
  <!-- Shell UI (stays until React confirms mount) -->
  <div class="loading-screen active" id="loading-screen" aria-live="polite">
    <div class="loading-spinner"></div>
    <div class="loading-content">
      <h1 class="loading-title">Violin Mastery Quest</h1>
      <p class="loading-subtitle">Adaptive modules â€¢ Offline-ready</p>

      <div class="loading-progress">
        <div class="progress-bar">
          <div class="progress-fill" id="loading-progress-fill" style="--width: 0%"></div>
        </div>
      </div>

      <p class="loading-status" id="loading-status">Initializingâ€¦</p>
      <div class="engine-status" id="engine-status" aria-live="polite"></div>
    </div>
  </div>

  <div class="toast-container" id="toast-container"></div>

  <div class="diagnostic-overlay" id="diagnostic-overlay" style="display:none;">
    <div class="diagnostic-content">
      <h2>ðŸ”§ VMQ Diagnostic Mode</h2>
      <pre id="diagnostic-log" style="white-space:pre-wrap;"></pre>
      <button id="diagnostic-reload" class="btn btn-primary" type="button">Reload App</button>
    </div>
  </div>

  <div id="root"></div>

  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script type="module">
    // Base-path derived from the directory that served THIS index.html (robust for GH Pages OR root)
    const BASE_URL  = new URL('./', import.meta.url);
    const BASE_PATH = BASE_URL.pathname; // e.g. "/violin-mastery-quest/" or "/"
    window.__VMQ_BASE_PATH__ = BASE_PATH;

    const startTime = performance.now();
    window.vmqMetrics = window.vmqMetrics || { loadTime: 0, engineInitTime: 0, mlWarmupTime: 0 };

    const isDiagnosticMode =
      window.location.search.includes('vmq-diagnostics') ||
      window.location.search.includes('debug=true');

    const diagnosticLog = [];
    function logDiagnostic(category, message, data = null) {
      const timestamp = (performance.now() - startTime).toFixed(2);
      const line = `[${timestamp}ms] [${category}] ${message}${data ? ' ' + JSON.stringify(data) : ''}`;
      diagnosticLog.push(line);

      if (isDiagnosticMode) {
        console.log(`%cVMQ Diagnostics: ${line}`, 'color:#3b82f6;font-weight:bold;');
        const logEl = document.getElementById('diagnostic-log');
        if (logEl) logEl.textContent = diagnosticLog.join('\n');
      }
    }

    function showDiagnosticOverlay(extraError = null) {
      const overlay = document.getElementById('diagnostic-overlay');
      if (!overlay || !isDiagnosticMode) return;

      overlay.style.display = 'flex';
      const logEl = document.getElementById('diagnostic-log');
      if (logEl) {
        logEl.textContent =
          diagnosticLog.join('\n') +
          (extraError ? `\n\n${extraError?.stack || String(extraError)}` : '');
      }
    }

    window.addEventListener('error', (event) => {
      logDiagnostic('ERROR', event.message, { filename: event.filename, lineno: event.lineno, colno: event.colno });
      showDiagnosticOverlay(event.error || event);
    });

    window.addEventListener('unhandledrejection', (event) => {
      const reason = event?.reason;
      logDiagnostic('PROMISE', reason?.message || 'Unhandled rejection', reason ? { reason: String(reason) } : null);
      if (isDiagnosticMode) showDiagnosticOverlay(reason);
    });

    document.getElementById('diagnostic-reload')?.addEventListener('click', () => window.location.reload());

    function setLoadingStatus(text) {
      const el = document.getElementById('loading-status');
      if (el) el.textContent = text;
    }
    function setProgress(percent) {
      const fill = document.getElementById('loading-progress-fill');
      if (fill) fill.style.setProperty('--width', `${Math.max(0, Math.min(100, percent))}%`);
    }

    // Fail-open feature gating (also compatible with App.js checkFeature)
    function checkFeature(featureName) {
      try {
        const features = window.VMQ?.FEATURES || window.VMQ?.features || {};
        return features?.[featureName]?.enabled !== false;
      } catch {
        return true;
      }
    }

    // Optional imports (MUST NOT hard-crash bootstrap)
    let ROUTE_TO_COMPONENT_FILE = Object.create(null);
    let normalizeRouteSlug = (s) => (s || '').toString().trim().toLowerCase();

    async function tryLoadRouteManifest() {
      try {
        const mod = await import(new URL('./js/config/routeManifest.js', BASE_URL).href);
        if (mod?.ROUTE_TO_COMPONENT_FILE) ROUTE_TO_COMPONENT_FILE = mod.ROUTE_TO_COMPONENT_FILE;
        if (typeof mod?.normalizeRouteSlug === 'function') normalizeRouteSlug = mod.normalizeRouteSlug;
        logDiagnostic('MANIFEST', 'routeManifest loaded');
      } catch (e) {
        logDiagnostic('MANIFEST', 'routeManifest missing/unavailable (continuing)', { err: String(e?.message || e) });
      }
    }

    // Engine health (degraded supported)
    const requiredEngines = [
      { name: 'audioEngine',       critical: true  },
      { name: 'gamification',      critical: true  },
      { name: 'sessionTracker',    critical: true  },
      { name: 'spacedRepetition',  critical: false },
      { name: 'analytics',         critical: false },
      { name: 'difficultyAdapter', critical: false }
    ];

    async function checkEngineHealth() {
      const statusEl = document.getElementById('engine-status');
      const status = {};
      let allCriticalOk = true;

      for (const e of requiredEngines) {
        try {
          const modUrl = new URL(`./js/engines/${e.name}.js`, BASE_URL).href;
          const mod = await import(modUrl);
          const ok = !!(mod && (mod.default || mod[e.name] || Object.keys(mod).length));
          status[e.name] = ok ? 'âœ…' : 'âŒ';
          if (!ok && e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: ${ok ? 'healthy' : 'failed'}`, { critical: e.critical });
        } catch (err) {
          status[e.name] = 'âŒ';
          if (e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: failed to load`, { critical: e.critical, err: String(err?.message || err) });
        }
      }

      if (statusEl) {
        statusEl.innerHTML = Object.entries(status)
          .map(([name, icon]) => `<span class="engine-indicator">${icon} ${name}</span>`)
          .join('');
      }

      return allCriticalOk;
    }

    // ML warmup (best-effort)
    async function warmupMLModels() {
      const wantAnalytics = checkFeature('analytics');
      const wantDA = checkFeature('difficultyAdapter');
      if (!wantAnalytics && !wantDA) return;

      const mlStart = performance.now();
      logDiagnostic('ML', 'Warming upâ€¦');

      try {
        const analyticsUrl  = new URL('./js/engines/analytics.js', BASE_URL).href;
        const difficultyUrl = new URL('./js/engines/difficultyAdapter.js', BASE_URL).href;

        const [analyticsMod, difficultyMod] = await Promise.allSettled([
          import(analyticsUrl),
          import(difficultyUrl)
        ]);

        if (analyticsMod.status === 'fulfilled' && typeof analyticsMod.value?.generateMLRecommendations === 'function') {
          // lightweight warmup
          await analyticsMod.value.generateMLRecommendations().catch(() => {});
          logDiagnostic('ML', 'Analytics warm');
        }

        if (difficultyMod.status === 'fulfilled' && typeof difficultyMod.value?.getAdaptiveConfig === 'function') {
          await difficultyMod.value.getAdaptiveConfig().catch(() => {});
          logDiagnostic('ML', 'Difficulty warm');
        }
      } catch (e) {
        logDiagnostic('ML', 'Warmup failed', { err: String(e?.message || e) });
      }

      window.vmqMetrics.mlWarmupTime = Math.round(performance.now() - mlStart);
      logDiagnostic('ML', `Warmup complete: ${window.vmqMetrics.mlWarmupTime}ms`);
    }

    // Prefetch (safe)
    function modulePreload(href) {
      if (!href) return;
      if (document.head.querySelector(`link[rel="modulepreload"][href="${href}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'modulepreload';
      link.href = href;
      document.head.appendChild(link);
    }

    function resolveComponentHref(routeOrId) {
      if (!routeOrId) return null;
      const raw = String(routeOrId).replace(/^#/, '').split('?')[0].trim();
      if (!raw) return null;
      const key = normalizeRouteSlug(raw);
      const file = ROUTE_TO_COMPONENT_FILE?.[key];
      return file ? new URL(`./js/components/${file}`, BASE_URL).href : null;
    }

    async function prefetchUserModules() {
      // No hard dependency on storage module: best-effort only
      let level = 'beginner';
      try {
        const raw = localStorage.getItem('vmq-profile') || localStorage.getItem('vmq.profile');
        const profile = raw ? JSON.parse(raw) : null;
        if (profile?.level) level = profile.level;
      } catch {}

      const modulesToPrefetch = {
        beginner:      ['intervals', 'keys', 'rhythm'],
        intermediate:  ['bieler', 'scales', 'fingerboard'],
        advanced:      ['bieler', 'scales', 'flashcards']
      };

      const list = modulesToPrefetch[level] || modulesToPrefetch.beginner;
      list.forEach((id) => modulePreload(resolveComponentHref(id)));
      logDiagnostic('PREFETCH', `modulepreload(${level})`, list);
    }

    // Service Worker registration (single owner, scope-correct)
    async function registerServiceWorker() {
      if (window.__VMQ_SW_REGISTERED__) {
        logDiagnostic('SW', 'Already registered (guard flag set)');
        return;
      }
      if (!checkFeature('pwaOffline') || !('serviceWorker' in navigator)) {
        logDiagnostic('SW', 'Disabled or unsupported');
        return;
      }

      try {
        const scopeUrl = BASE_URL.href; // directory scope of index.html
        const existing = await navigator.serviceWorker.getRegistration(scopeUrl);
        let registration = existing;

        if (!registration) {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = 'index.html';

          const swUrl = new URL('./sw.js', BASE_URL).href;
          registration = await navigator.serviceWorker.register(swUrl, {
            scope: BASE_PATH,
            updateViaCache: 'none'
          });
          logDiagnostic('SW', `Registered`, { scope: registration.scope });
        } else {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = window.__VMQ_SW_OWNER__ || 'existing';
          logDiagnostic('SW', `Using existing registration`, { scope: registration.scope });
        }

        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              logDiagnostic('SW', 'Update available');
              window.dispatchEvent(new CustomEvent('vmq-update-available', {
                detail: { version: '3.0.4', cacheBust: Date.now() }
              }));
            }
          });
        });

        // Best-effort registrations
        await navigator.serviceWorker.ready.then(async (reg) => {
          if (reg.sync) {
            try { await reg.sync.register('sync-analytics'); logDiagnostic('SYNC', 'sync-analytics registered'); } catch {}
            try { await reg.sync.register('sync-sm2');       logDiagnostic('SYNC', 'sync-sm2 registered'); } catch {}
          }
          if (reg.periodicSync) {
            try {
              await reg.periodicSync.register('check-due-items', { minInterval: 30 * 60 * 1000 });
              logDiagnostic('SYNC', 'periodicSync: check-due-items registered');
            } catch {}
          }
        }).catch(() => {});
      } catch (err) {
        window.__VMQ_SW_REGISTERED__ = false;
        logDiagnostic('SW', 'Registration failed', { err: String(err?.message || err) });
      }
    }

    // Keep shell visible until React confirms mount
    function waitForReactMount({ timeoutMs = 12000 } = {}) {
      return new Promise((resolve) => {
        let done = false;

        const finish = (why) => {
          if (done) return;
          done = true;
          resolve(why);
        };

        const onMounted = () => finish('vmq-app-mounted');
        window.addEventListener('vmq-app-mounted', onMounted, { once: true });

        // Hard timeout: never leave user on a hidden shell with blank app
        setTimeout(() => finish('timeout'), timeoutMs);
      });
    }

    // Bootstrap sequence
    async function bootstrap() {
      setProgress(10);
      setLoadingStatus('Preparingâ€¦');

      await tryLoadRouteManifest();
      setProgress(20);

      setLoadingStatus('Warming upâ€¦');
      await warmupMLModels();
      setProgress(40);

      setLoadingStatus('Checking enginesâ€¦');
      const criticalOk = await checkEngineHealth();
      if (!criticalOk) setLoadingStatus('Some features unavailable, continuingâ€¦');
      setProgress(60);

      setLoadingStatus('Prefetchingâ€¦');
      await prefetchUserModules();
      setProgress(75);

      setLoadingStatus('Enabling offlineâ€¦');
      await registerServiceWorker();
      setProgress(90);

      window.vmqMetrics.engineInitTime = Math.round(performance.now() - startTime);
      setProgress(100);
      logDiagnostic('BOOTSTRAP', 'Complete', window.vmqMetrics);
    }

    // Run bootstrap and then wait for React to confirm mount before hiding shell
    bootstrap().then(async () => {
      const why = await waitForReactMount({ timeoutMs: 12000 });

      if (why === 'timeout') {
        // Keep shell up and show diagnostics hint (prevents â€œblank screenâ€ perception)
        logDiagnostic('BOOTSTRAP', 'React mount timeout (shell retained)');
        setLoadingStatus('Still loadingâ€¦ If stuck, enable ?vmq-diagnostics');
        if (isDiagnosticMode) showDiagnosticOverlay(null);
        return;
      }

      // React confirmed mount
      document.getElementById('loading-screen')?.classList.remove('active');
      window.dispatchEvent(new CustomEvent('vmq-ready', { detail: { metrics: window.vmqMetrics, diagnosticLog } }));
    }).catch((err) => {
      logDiagnostic('BOOTSTRAP', 'Fatal error', { err: String(err?.message || err) });
      showDiagnosticOverlay(err);
      setLoadingStatus('Error loading VMQ. Enable diagnostics for details.');
    });
  </script>

  <!-- App entry -->
  <script type="module" src="./js/App.js"></script>
  <script>
(function() {
    console.log("VMQ Watchdog: Active and monitoring...");

    const checkInterval = setInterval(() => {
        // 1. Identify the Loading Screen
        // We look for the container holding the "Still loading" text or the progress bar
        const loadingScreen = document.querySelector('.loading-overlay') || 
                              document.querySelector('#loading-screen') ||
                              Array.from(document.querySelectorAll('div')).find(el => el.innerText.includes("Still loading"));

        if (!loadingScreen || loadingScreen.style.display === 'none') {
            // Loader is gone, app is running fine. Stop watching.
            clearInterval(checkInterval);
            return;
        }

        // 2. Check Diagnostics (The "Green Checkmarks")
        // We check if the modules listed in your screenshot are actually marked as done
        const requiredModules = ['audioEngine', 'gamification', 'sessionTracker', 'spacedRepetition', 'analytics', 'difficultyAdapter'];
        let allReady = true;
        
        // Count how many are checked/green
        let checkedCount = 0;

        requiredModules.forEach(id => {
            const checkbox = document.getElementById(id) || document.querySelector(`[name="${id}"]`);
            // Check if the checkbox exists and is checked
            if (checkbox && checkbox.checked) {
                checkedCount++;
            } else if (checkbox) {
                // If the checkbox exists but isn't checked, we aren't ready yet
                allReady = false;
            }
        });

        // 3. The Fix Logic
        // If all modules are checked, OR if the app has been stuck for more than 8 seconds
        // we force the transition.
        const isStuck = (checkedCount === requiredModules.length);
        
        if (isStuck) {
            console.warn("VMQ Watchdog: Hang detected (All modules ready). Forcing start...");
            
            // A. Force Audio Unlock (Crucial for Audio Apps)
            // We attach a one-time listener to resume audio on the first click anywhere
            const unlockAudio = () => {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    // Try to find the existing context if accessible, or just resume the global one
                    // This is a generic "resume" call safe for most setups
                    if (window.audioCtx && window.audioCtx.state === 'suspended') {
                        window.audioCtx.resume();
                    }
                }
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('touchstart', unlockAudio);
            };
            document.addEventListener('click', unlockAudio);
            document.addEventListener('touchstart', unlockAudio);

            // B. Remove the Loading Screen
            loadingScreen.style.transition = "opacity 0.5s ease";
            loadingScreen.style.opacity = "0";
            
            clearInterval(checkInterval);

            setTimeout(() => {
                loadingScreen.style.display = "none";
                // Dispatch a generic window resize event to force layout recalculations (fixes canvas rendering issues)
                window.dispatchEvent(new Event('resize'));
            }, 500);
        }

    }, 1000); // Checks every 1 second
})();
</script>
</body>
</html>