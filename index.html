<!-- index.html
========================================================
VMQ index.html (Drop-in replacement) â€” v3.0.7 (routeManifest v2.3.3 aligned)
Merged â€œbest-ofâ€ (no feature loss):
- âœ… Deterministic CSS cascade (base â†’ themes â†’ components â†’ animations)
- âœ… Never blank: shell stays until vmq-app-mounted OR timeout
- âœ… GH Pages safe: robust base-path from import.meta.url
- âœ… SW registration guarded + scope correct + forwards SW messages
- âœ… Diagnostic overlay + global error capture
- âœ… No-devtools fatal box shows failing import URL on timeout/import fail
- âœ… Recover button: clears SW + caches (manual) + optional one-time auto-recover
- âœ… NEW: routeManifest v2.3.3 perfect integration (normalizeRouteSlug + getComponentFileForRoute)
========================================================
-->
<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#3b82f6" />
  <meta name="color-scheme" content="light dark" />

  <!-- CSP: compatible with inline module bootstrap + React UMD -->
  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://unpkg.com 'unsafe-inline';
          style-src 'self' 'unsafe-inline';
          connect-src 'self' https://unpkg.com;
          img-src 'self' data: blob:;
          font-src 'self' data:;
          media-src 'self' blob:;
          worker-src 'self' blob:;
          object-src 'none';
          base-uri 'self';
          frame-ancestors 'none';
        " />

  <!-- PWA / Apple -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="Violin Mastery Quest" />
  <meta name="application-name" content="VMQ" />

  <meta name="description" content="Violin Mastery Quest v3 â€” adaptive violin training: intervals, fingerboard, scales, rhythm, SM-2, AI coach." />
  <title>Violin Mastery Quest</title>

  <meta property="og:title" content="Violin Mastery Quest" />
  <meta property="og:description" content="Adaptive violin training: Bieler Method + spaced repetition + AI coach" />
  <meta property="og:image" content="./icons/icon-512.png" />
  <meta property="og:type" content="website" />

  <link rel="manifest" href="./manifest.json" />

  <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-32.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png" />

  <link rel="preconnect" href="https://unpkg.com" crossorigin />
  <link rel="dns-prefetch" href="https://unpkg.com" />

  <!-- Preload modules -->
  <link rel="modulepreload" href="./js/App.js" />
  <link rel="modulepreload" href="./js/config/routeManifest.js" />

  <!-- CSS (deterministic order) -->
  <link rel="stylesheet" href="./css/base.css" />

  <link rel="preload" href="./css/themes.css" as="style" />
  <link rel="preload" href="./css/components.css" as="style" />
  <link rel="preload" href="./css/animations.css" as="style" />

  <link rel="stylesheet" href="./css/themes.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/components.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/animations.css" media="print" onload="this.media='all'">

  <noscript>
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/components.css">
    <link rel="stylesheet" href="./css/animations.css">
  </noscript>

  <!-- Ensure slash-less rgb var compatibility -->
  <style>:root { --primary-rgb: 59 130 246; }</style>

  <!-- Minimal boot-fallback styling (safe even if CSS fails) -->
  <style>
    .vmq-fatal {
      margin-top:12px; padding:12px; border:1px solid rgba(239,68,68,.65);
      background:rgba(239,68,68,.08); border-radius:12px; text-align:left;
      max-width:680px; word-break:break-word;
      font-family:ui-monospace,Menlo,monospace; font-size:12px;
    }
    .vmq-fatal b{font-weight:900}
    .vmq-boot-actions{margin-top:10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap}
  </style>
</head>

<body>
  <!-- Shell UI (stays until React confirms mount) -->
  <div class="loading-screen active" id="loading-screen" aria-live="polite">
    <div class="loading-spinner"></div>
    <div class="loading-content" style="text-align:center">
      <h1 class="loading-title">Violin Mastery Quest</h1>
      <p class="loading-subtitle">Adaptive modules â€¢ Offline-ready</p>

      <div class="loading-progress" style="margin:var(--space-lg,16px) 0 0">
        <div class="progress-bar" style="width:240px;margin:0 auto">
          <div class="progress-fill" id="loading-progress-fill" style="width:0%; --width:0%"></div>
        </div>
      </div>

      <p class="loading-status" id="loading-status">Initializingâ€¦</p>
      <div class="engine-status" id="engine-status" aria-live="polite" style="margin-top:10px"></div>

      <!-- No-devtools fatal box -->
      <div id="vmq-fatal-box" class="vmq-fatal" style="display:none;"></div>

      <div class="vmq-boot-actions">
        <button class="btn btn-primary" type="button" id="vmq-reload-btn">Reload</button>
        <button class="btn btn-secondary" type="button" id="vmq-recover-btn">Recover (clear SW/cache)</button>
      </div>
    </div>
  </div>

  <div class="toast-container" id="toast-container"></div>

  <div class="diagnostic-overlay" id="diagnostic-overlay" style="display:none;">
    <div class="diagnostic-content">
      <h2>ðŸ”§ VMQ Diagnostic Mode</h2>
      <pre id="diagnostic-log" style="white-space:pre-wrap;"></pre>
      <button id="diagnostic-reload" class="btn btn-primary" type="button">Reload App</button>
    </div>
  </div>

  <div id="root"></div>

  <!-- React 18 UMD (App.js uses window.React / window.ReactDOM) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Single owner module: listeners â†’ probes â†’ app import â†’ bootstrap â†’ wait mount -->
  <script type="module">
    // ------------------------------------------------------------
    // Base-path derived from the directory serving THIS index.html
    // ------------------------------------------------------------
    const BASE_URL  = new URL('./', import.meta.url);
    const BASE_PATH = BASE_URL.pathname; // "/violin-mastery-quest/" or "/"
    const APP_URL   = new URL('./js/App.js', BASE_URL).href;
    const SW_URL    = new URL('./sw.js', BASE_URL).href;

    window.__VMQ_BASE_PATH__ = BASE_PATH;
    window.__VMQ_APP_URL__   = APP_URL;

    const qs = new URL(location.href).searchParams;
    const isDiagnosticMode =
      qs.get('vmq-diagnostics') === '1' ||
      qs.get('vmq-diagnostics') === 'true' ||
      qs.get('debug') === 'true' ||
      location.search.includes('vmq-diagnostics');

    const RECOVERY_KEY = 'vmq-recovery-attempted-v1';
    const recoveryAttempted = sessionStorage.getItem(RECOVERY_KEY) === '1';

    const $status = document.getElementById('loading-status');
    const $bar    = document.getElementById('loading-progress-fill');
    const $eng    = document.getElementById('engine-status');
    const $fatal  = document.getElementById('vmq-fatal-box');
    const $shell  = document.getElementById('loading-screen');

    const startTime = (performance?.now ? performance.now() : Date.now());
    window.vmqMetrics = window.vmqMetrics || { loadTime: 0, engineInitTime: 0, mlWarmupTime: 0 };

    const diagnosticLog = [];
    function logDiagnostic(category, message, data = null) {
      const now = (performance?.now ? performance.now() : Date.now());
      const ts = (now - startTime).toFixed(2);
      const line = `[${ts}ms] [${category}] ${message}${data ? ' ' + JSON.stringify(data) : ''}`;
      diagnosticLog.push(line);

      if (isDiagnosticMode) {
        console.log(`%cVMQ Diagnostics: ${line}`, 'color:#3b82f6;font-weight:bold;');
        const logEl = document.getElementById('diagnostic-log');
        if (logEl) logEl.textContent = diagnosticLog.join('\n');
      }
    }

    function showDiagnosticOverlay(extraError = null) {
      const overlay = document.getElementById('diagnostic-overlay');
      if (!overlay || !isDiagnosticMode) return;

      overlay.style.display = 'flex';
      const logEl = document.getElementById('diagnostic-log');
      if (logEl) {
        logEl.textContent =
          diagnosticLog.join('\n') +
          (extraError ? `\n\n${extraError?.stack || String(extraError)}` : '');
      }
    }

    document.getElementById('diagnostic-reload')?.addEventListener('click', () => location.reload());

    function setStatus(t) { if ($status) $status.textContent = t; }
    function setProgress(p) {
      const v = Math.max(0, Math.min(100, p));
      if ($bar) {
        $bar.style.width = `${v}%`;
        $bar.style.setProperty('--width', `${v}%`);
      }
    }

    function extractUrl(text) {
      const s = String(text || '');
      const m =
        s.match(/https?:\/\/[^\s'"]+/) ||
        s.match(/(?:\.\/|\/)js\/[^\s'"]+\.js(?:\?[^\s'"]+)?/);
      return m ? m[0] : null;
    }

    function showBootFatal(title, info = {}) {
      if (!$fatal) return;

      const swState =
        ('serviceWorker' in navigator)
          ? (navigator.serviceWorker.controller ? 'controlling' : 'not controlling')
          : 'unsupported';

      const basePath = window.__VMQ_BASE_PATH__ || '(unknown)';
      const appUrl = window.__VMQ_APP_URL__ || '(unknown)';
      const msg = info.message || '';
      const url =
        info.failingUrl ||
        extractUrl(msg) ||
        extractUrl(info.stack) ||
        extractUrl(info.reason) ||
        '(not found)';

      $fatal.style.display = 'block';
      $fatal.innerHTML =
        `<div style="font-weight:900;margin-bottom:6px;">ðŸš¨ ${title}</div>` +
        `<div><b>Failing URL:</b> ${url}</div>` +
        `<div><b>App URL:</b> ${appUrl}</div>` +
        `<div><b>Base path:</b> ${basePath}</div>` +
        `<div><b>SW:</b> ${swState}</div>` +
        (msg ? `<div style="margin-top:6px;"><b>Message:</b> ${msg}</div>` : '') +
        (info.stack ? `<div style="margin-top:6px;white-space:pre-wrap;"><b>Stack:</b>\n${info.stack}</div>` : '');
    }

    // ------------------------------------------------------------
    // Global error capture (Safari-friendly)
    // ------------------------------------------------------------
    window.__VMQ_LAST_ERROR__ = null;

    window.addEventListener('error', (event) => {
      logDiagnostic('ERROR', event.message, { filename: event.filename, lineno: event.lineno, colno: event.colno });
      window.__VMQ_LAST_ERROR__ = {
        message: event.message,
        stack: event?.error?.stack || '',
        failingUrl: event.filename || extractUrl(event.message) || null
      };
      showDiagnosticOverlay(event.error || event);
    });

    window.addEventListener('unhandledrejection', (event) => {
      const r = event?.reason;
      logDiagnostic('PROMISE', r?.message || 'Unhandled rejection', r ? { reason: String(r) } : null);
      window.__VMQ_LAST_ERROR__ = {
        message: r?.message || String(r),
        stack: r?.stack || '',
        failingUrl: extractUrl(r?.message) || extractUrl(String(r)) || null
      };
      if (isDiagnosticMode) showDiagnosticOverlay(r);
    });

    // App import failure event (from loader below)
    window.addEventListener('vmq-app-import-failed', (e) => {
      const detail = e?.detail || {};
      logDiagnostic('APP', 'App module failed to import', { appUrl: detail.appUrl, failingUrl: detail.failingUrl, message: detail.message });
      showBootFatal('App module failed to import', {
        message: detail.message,
        stack: detail.stack,
        failingUrl: detail.failingUrl || extractUrl(detail.message) || extractUrl(detail.stack) || null
      });
    });

    // ------------------------------------------------------------
    // Fail-open feature gating (compatible with App.js checkFeature)
    // ------------------------------------------------------------
    function checkFeature(featureName) {
      try {
        const features = window.VMQ?.FEATURES || window.VMQ?.features || {};
        return features?.[featureName]?.enabled !== false;
      } catch {
        return true;
      }
    }

    // ------------------------------------------------------------
    // Recovery helpers
    // ------------------------------------------------------------
    async function purgeServiceWorkerAndCaches() {
      const report = { action: 'purge', ok: true, sw: [], caches: [], ts: Date.now() };
      try {
        if ('serviceWorker' in navigator) {
          const regs = await navigator.serviceWorker.getRegistrations();
          report.sw = regs.map(r => ({ scope: r.scope, active: !!r.active, waiting: !!r.waiting, installing: !!r.installing }));
          await Promise.all(regs.map(r => r.unregister()));
        }
        if ('caches' in window) {
          const keys = await caches.keys();
          report.caches = keys.slice();
          await Promise.all(keys.map(k => caches.delete(k)));
        }
      } catch (e) {
        report.ok = false;
        report.error = e?.message || String(e);
      }
      return report;
    }

    document.getElementById('vmq-reload-btn')?.addEventListener('click', () => location.reload());

    document.getElementById('vmq-recover-btn')?.addEventListener('click', async () => {
      setStatus('Recoveringâ€¦');
      logDiagnostic('RECOVER', 'Manual recover triggered');
      await purgeServiceWorkerAndCaches();
      location.href = `${BASE_URL.href}?recovered=1&t=${Date.now()}`;
    });

    async function tryRecoverOnce(reason, detail = {}) {
      if (recoveryAttempted) return false;
      sessionStorage.setItem(RECOVERY_KEY, '1');

      setStatus('Auto-recoveringâ€¦');
      logDiagnostic('RECOVER', 'Auto recover', { reason, detail });
      await purgeServiceWorkerAndCaches();

      location.href = `${BASE_URL.href}?autofix=1&t=${Date.now()}`;
      return true;
    }

    // Optional: query flag to hard-reset
    if (qs.get('vmq-reset') === '1') {
      setStatus('Resetting offline dataâ€¦');
      logDiagnostic('RECOVER', 'vmq-reset=1 requested');
      purgeServiceWorkerAndCaches().then(() => {
        const u = new URL(location.href);
        u.searchParams.delete('vmq-reset');
        location.href = u.href;
      });
    }

    // ------------------------------------------------------------
    // Forward SW messages into window events (aligns with SW v3.0.7)
    // ------------------------------------------------------------
    function hookServiceWorkerMessages() {
      if (!('serviceWorker' in navigator)) return;

      navigator.serviceWorker.addEventListener('message', (event) => {
        const msg = event?.data || {};
        if (!msg?.type) return;

        if (msg.type === 'vmq-update-available') {
          logDiagnostic('SW', 'Message: update available', msg.data || {});
          window.dispatchEvent(new CustomEvent('vmq-update-available', { detail: msg.data || {} }));
          return;
        }
        if (msg.type === 'VMQ_SW_ACTIVE') {
          logDiagnostic('SW', 'Message: active', msg.data || {});
          window.dispatchEvent(new CustomEvent('vmq-sw-active', { detail: msg.data || {} }));
          return;
        }

        window.dispatchEvent(new CustomEvent('vmq-sw-message', { detail: msg }));
      });
    }
    hookServiceWorkerMessages();

    // ------------------------------------------------------------
    // routeManifest v2.3.3 integration (perfect alignment)
    // ------------------------------------------------------------
    let ROUTE_TO_COMPONENT_FILE = Object.create(null);
    let normalizeRouteSlug = (s) => (s || '').toString().trim().toLowerCase();
    let getComponentFileForRoute = (route) => {
      try {
        const slug = normalizeRouteSlug(route);
        return ROUTE_TO_COMPONENT_FILE?.[slug] || null;
      } catch {
        return null;
      }
    };

    async function tryLoadRouteManifest() {
      try {
        const mod = await import(new URL('./js/config/routeManifest.js', BASE_URL).href);

        if (mod?.ROUTE_TO_COMPONENT_FILE) ROUTE_TO_COMPONENT_FILE = mod.ROUTE_TO_COMPONENT_FILE;
        if (typeof mod?.normalizeRouteSlug === 'function') normalizeRouteSlug = mod.normalizeRouteSlug;

        // Prefer the helper provided by v2.3.3 (handles aliases + normalization internally)
        if (typeof mod?.getComponentFileForRoute === 'function') {
          getComponentFileForRoute = mod.getComponentFileForRoute;
        } else {
          // fallback already defined above
        }

        // Expose for debugging (read-only use)
        window.__VMQ_ROUTE_MANIFEST__ = Object.freeze({
          normalizeRouteSlug,
          getComponentFileForRoute,
          ROUTE_TO_COMPONENT_FILE
        });

        logDiagnostic('MANIFEST', 'routeManifest loaded (v2.3.3 aligned)');
      } catch (e) {
        logDiagnostic('MANIFEST', 'routeManifest missing/unavailable (continuing)', { err: String(e?.message || e) });
      }
    }

    // Prefetch (safe)
    function modulePreload(href) {
      if (!href) return;
      if (document.head.querySelector(`link[rel="modulepreload"][href="${href}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'modulepreload';
      link.href = href;
      document.head.appendChild(link);
    }

    function resolveComponentHref(routeOrId) {
      const file = getComponentFileForRoute(routeOrId); // âœ… v2.3.3 canonical + alias aware
      return file ? new URL(`./js/components/${file}`, BASE_URL).href : null;
    }

    async function prefetchUserModules() {
      let level = 'beginner';
      try {
        const raw = localStorage.getItem('vmq-profile') || localStorage.getItem('vmq.profile');
        const profile = raw ? JSON.parse(raw) : null;
        if (profile?.level) level = profile.level;
      } catch {}

      const modulesToPrefetch = {
        beginner:      ['intervals', 'keys', 'rhythm'],
        intermediate:  ['bieler', 'scales', 'fingerboard'],
        advanced:      ['bielerlab', 'scaleslab', 'flashcards'] // âœ… includes alias forms; manifest will canonicalize
      };

      const list = modulesToPrefetch[level] || modulesToPrefetch.beginner;
      list.forEach((id) => modulePreload(resolveComponentHref(id)));

      logDiagnostic('PREFETCH', `modulepreload(${level})`, list);
    }

    // ------------------------------------------------------------
    // Engine health (degraded supported)
    // ------------------------------------------------------------
    const requiredEngines = [
      { name: 'audioEngine',       critical: true  },
      { name: 'gamification',      critical: true  },
      { name: 'sessionTracker',    critical: true  },
      { name: 'spacedRepetition',  critical: false },
      { name: 'analytics',         critical: false },
      { name: 'difficultyAdapter', critical: false }
    ];

    async function checkEngineHealth() {
      const status = {};
      let allCriticalOk = true;

      for (const e of requiredEngines) {
        try {
          const modUrl = new URL(`./js/engines/${e.name}.js`, BASE_URL).href;
          const mod = await import(modUrl);
          const ok = !!(mod && (mod.default || mod[e.name] || Object.keys(mod).length));
          status[e.name] = ok ? 'âœ…' : 'âŒ';
          if (!ok && e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: ${ok ? 'healthy' : 'failed'}`, { critical: e.critical });
        } catch (err) {
          status[e.name] = 'âŒ';
          if (e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: failed to load`, { critical: e.critical, err: String(err?.message || err) });
        }
      }

      if ($eng) {
        $eng.innerHTML = Object.entries(status)
          .map(([name, icon]) => `<span class="engine-indicator">${icon} ${name}</span>`)
          .join(' ');
      }

      return allCriticalOk;
    }

    // ML warmup (best-effort)
    async function warmupMLModels() {
      const wantAnalytics = checkFeature('analytics');
      const wantDA = checkFeature('difficultyAdapter');
      if (!wantAnalytics && !wantDA) return;

      const mlStart = (performance?.now ? performance.now() : Date.now());
      logDiagnostic('ML', 'Warming upâ€¦');

      try {
        const analyticsUrl  = new URL('./js/engines/analytics.js', BASE_URL).href;
        const difficultyUrl = new URL('./js/engines/difficultyAdapter.js', BASE_URL).href;

        const [analyticsMod, difficultyMod] = await Promise.allSettled([
          import(analyticsUrl),
          import(difficultyUrl)
        ]);

        if (analyticsMod.status === 'fulfilled' && typeof analyticsMod.value?.generateMLRecommendations === 'function') {
          await analyticsMod.value.generateMLRecommendations().catch(() => {});
          logDiagnostic('ML', 'Analytics warm');
        }

        if (difficultyMod.status === 'fulfilled' && typeof difficultyMod.value?.getAdaptiveConfig === 'function') {
          await difficultyMod.value.getAdaptiveConfig().catch(() => {});
          logDiagnostic('ML', 'Difficulty warm');
        }
      } catch (e) {
        logDiagnostic('ML', 'Warmup failed', { err: String(e?.message || e) });
      }

      const now = (performance?.now ? performance.now() : Date.now());
      window.vmqMetrics.mlWarmupTime = Math.round(now - mlStart);
      logDiagnostic('ML', `Warmup complete: ${window.vmqMetrics.mlWarmupTime}ms`);
    }

    // ------------------------------------------------------------
    // Service Worker registration (single owner, scope-correct)
    // ------------------------------------------------------------
    async function registerServiceWorker() {
      if (window.__VMQ_SW_REGISTERED__) {
        logDiagnostic('SW', 'Already registered (guard flag set)');
        return;
      }
      if (!checkFeature('pwaOffline') || !('serviceWorker' in navigator)) {
        logDiagnostic('SW', 'Disabled or unsupported');
        return;
      }

      try {
        const existing = await navigator.serviceWorker.getRegistration(BASE_URL.href);
        let registration = existing;

        if (!registration) {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = 'index.html';

          registration = await navigator.serviceWorker.register(SW_URL, {
            scope: BASE_PATH,
            updateViaCache: 'none'
          });
          logDiagnostic('SW', 'Registered', { scope: registration.scope });
        } else {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = window.__VMQ_SW_OWNER__ || 'existing';
          logDiagnostic('SW', 'Using existing registration', { scope: registration.scope });
        }

        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              logDiagnostic('SW', 'Update available (updatefound)');
              window.dispatchEvent(new CustomEvent('vmq-update-available', {
                detail: { version: '3.0.9.0.9', cacheBust: Date.now() }
              }));
            }
          });
        });

        navigator.serviceWorker.ready.then(async (reg) => {
          if (reg.sync) {
            try { await reg.sync.register('sync-analytics'); logDiagnostic('SYNC', 'sync-analytics registered'); } catch {}
            try { await reg.sync.register('sync-sm2');       logDiagnostic('SYNC', 'sync-sm2 registered'); } catch {}
          }
          if (reg.periodicSync) {
            try {
              await reg.periodicSync.register('check-due-items', { minInterval: 30 * 60 * 1000 });
              logDiagnostic('SYNC', 'periodicSync: check-due-items registered');
            } catch {}
          }
        }).catch(() => {});
      } catch (err) {
        window.__VMQ_SW_REGISTERED__ = false;
        logDiagnostic('SW', 'Registration failed', { err: String(err?.message || err) });
      }
    }

    // ------------------------------------------------------------
    // App import preflight (prevents â€œHTML served for JSâ€ poison)
    // ------------------------------------------------------------
    function extractStaticImports(jsText) {
      const out = new Set();
      const re1 = /import\s+[^'"]*?\s+from\s+['"]([^'"]+)['"]/g;
      const re2 = /import\s+['"]([^'"]+)['"]/g;
      let m;
      while ((m = re1.exec(jsText))) out.add(m[1]);
      while ((m = re2.exec(jsText))) out.add(m[1]);
      return [...out];
    }

    async function probeJs(url) {
      const res = await fetch(url, { cache: 'no-store' });
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (!res.ok) return { ok: false, why: `HTTP ${res.status}`, ct };
      if (ct.includes('text/html')) return { ok: false, why: `Served as HTML (${ct})`, ct };
      if (!ct.includes('javascript') && !ct.includes('ecmascript') && !ct.includes('text/plain')) {
        return { ok: false, why: `Bad MIME: ${ct || '(none)'}`, ct };
      }
      return { ok: true, why: 'ok', ct };
    }

    async function preflightApp(appUrl) {
      const appRes = await fetch(appUrl, { cache: 'no-store' });
      const appCt = (appRes.headers.get('content-type') || '').toLowerCase();
      if (!appRes.ok) return { failingUrl: appUrl, detail: `App.js HTTP ${appRes.status}` };
      if (appCt.includes('text/html')) return { failingUrl: appUrl, detail: `App.js served as HTML (${appCt})` };

      const appText = await appRes.text();
      const specs = extractStaticImports(appText)
        .filter(s => s.startsWith('./') || s.startsWith('../') || s.startsWith('/'));

      for (const spec of specs.slice(0, 80)) {
        const url = new URL(spec, appUrl).href;
        const r = await probeJs(url);
        if (!r.ok) return { failingUrl: url, detail: r.why, contentType: r.ct, spec };
      }
      return null;
    }

    function dispatchImportFailed(err, failingUrl, extra = {}) {
      const detail = {
        appUrl: APP_URL,
        failingUrl: failingUrl || null,
        message: err?.message || String(err),
        stack: err?.stack || '',
        when: new Date().toISOString(),
        ...extra
      };
      window.__VMQ_APP_IMPORT_ERROR__ = detail;
      window.dispatchEvent(new CustomEvent('vmq-app-import-failed', { detail }));
    }

    // ------------------------------------------------------------
    // Mount wait (shell stays until vmq-app-mounted)
    // ------------------------------------------------------------
    function waitForReactMount({ timeoutMs = 12000 } = {}) {
      try { if (window.__VMQ_MOUNTED__) return Promise.resolve('already-mounted'); } catch {}

      return new Promise((resolve) => {
        let done = false;
        const finish = (why) => { if (!done) { done = true; resolve(why); } };
        window.addEventListener('vmq-app-mounted', () => finish('vmq-app-mounted'), { once: true });
        setTimeout(() => finish('timeout'), timeoutMs);
      });
    }

    // ------------------------------------------------------------
    // Bootstrap sequence (best-effort, fail-open)
    // ------------------------------------------------------------
    async function bootstrap() {
      setProgress(10);
      setStatus('Checking environmentâ€¦');

      if (!window.React || !window.ReactDOM) {
        showBootFatal('React failed to load', { message: 'React UMD globals missing.' });
        return;
      }

      setProgress(20);
      setStatus('Preparingâ€¦');
      await tryLoadRouteManifest();
      logDiagnostic('BOOT', 'Base', { BASE_PATH, APP_URL, SW_URL });

      setProgress(35);
      setStatus('Warming upâ€¦');
      await warmupMLModels();

      setProgress(50);
      setStatus('Checking enginesâ€¦');
      const criticalOk = await checkEngineHealth();
      if (!criticalOk) setStatus('Some features unavailable, continuingâ€¦');

      setProgress(65);
      setStatus('Prefetchingâ€¦');
      await prefetchUserModules();

      setProgress(78);
      setStatus('Enabling offlineâ€¦');
      await registerServiceWorker();

      setProgress(90);
      setStatus('Loading app moduleâ€¦');

      const fail = await preflightApp(APP_URL);
      if (fail) {
        dispatchImportFailed(new Error(`Preflight failed: ${fail.detail}`), fail.failingUrl, fail);
        await tryRecoverOnce('preflight-failed', fail);
        return;
      }

      try {
        await import(APP_URL);
        setProgress(100);
        setStatus('Finalizingâ€¦');
      } catch (err) {
        dispatchImportFailed(err, null);
        await tryRecoverOnce('module-import-failed', { message: err?.message || String(err), stack: err?.stack || '' });
      }
    }

    // ------------------------------------------------------------
    // Run: bootstrap then wait for mount; never blank the screen
    // ------------------------------------------------------------
    (async () => {
      try {
        const mountPromise = waitForReactMount({ timeoutMs: 12000 });
        await bootstrap();

        const why = await mountPromise;
        if (why === 'timeout') {
          logDiagnostic('BOOT', 'React mount timeout (shell retained)');
          setStatus('Still loadingâ€¦ If stuck, enable ?vmq-diagnostics=1');
          showBootFatal('Mount timeout (React never mounted)', window.__VMQ_APP_IMPORT_ERROR__ || window.__VMQ_LAST_ERROR__ || {});
          showDiagnosticOverlay(null);
          await tryRecoverOnce('mount-timeout', window.__VMQ_APP_IMPORT_ERROR__ || window.__VMQ_LAST_ERROR__ || {});
          return;
        }

        $shell?.classList.remove('active');
        const now = (performance?.now ? performance.now() : Date.now());
        window.vmqMetrics.loadTime = Math.round(now - startTime);

        window.dispatchEvent(new CustomEvent('vmq-ready', {
          detail: { metrics: window.vmqMetrics, diagnosticLog }
        }));
      } catch (err) {
        logDiagnostic('BOOT', 'Fatal bootstrap error', { err: String(err?.message || err) });
        setStatus('Error loading VMQ. Enable diagnostics for details.');
        showBootFatal('Fatal bootstrap error', { message: err?.message || String(err), stack: err?.stack || '' });
        showDiagnosticOverlay(err);
        await tryRecoverOnce('fatal-bootstrap', { message: err?.message || String(err), stack: err?.stack || '' });
      }
    })();
  </script>
</body>
</html>
