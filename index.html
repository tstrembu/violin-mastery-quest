<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#3b82f6" />
  <meta name="color-scheme" content="light dark" />

  <meta http-equiv="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://unpkg.com 'unsafe-inline';
          style-src 'self' 'unsafe-inline';
          connect-src 'self' https://unpkg.com;
          img-src 'self' data:;
          font-src 'self';
          media-src 'self';
          object-src 'none';
          base-uri 'self';
          frame-ancestors 'none';
        " />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="apple-mobile-web-app-title" content="Violin Mastery Quest" />
  <meta name="application-name" content="VMQ" />

  <meta name="description" content="Violin Mastery Quest v3 â€” adaptive violin training: intervals, fingerboard, scales, rhythm, SM-2, AI coach." />
  <title>Violin Mastery Quest</title>

  <meta property="og:title" content="Violin Mastery Quest" />
  <meta property="og:description" content="Adaptive violin training: Bieler Method + spaced repetition + AI coach" />
  <meta property="og:image" content="./icons/icon-512.png" />
  <meta property="og:type" content="website" />

  <link rel="manifest" href="./manifest.json" />

  <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-16.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-32.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png" />

  <link rel="preconnect" href="https://unpkg.com" crossorigin />
  <link rel="dns-prefetch" href="https://unpkg.com" />

  <link rel="modulepreload" href="./js/App.js" />
  <link rel="modulepreload" href="./js/config/routeManifest.js" />

  <link rel="stylesheet" href="./css/base.css" />

  <link rel="preload" href="./css/themes.css" as="style" />
  <link rel="preload" href="./css/components.css" as="style" />
  <link rel="preload" href="./css/animations.css" as="style" />

  <link rel="stylesheet" href="./css/themes.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/components.css" media="print" onload="this.media='all'">
  <link rel="stylesheet" href="./css/animations.css" media="print" onload="this.media='all'">

  <noscript>
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/components.css">
    <link rel="stylesheet" href="./css/animations.css">
  </noscript>

  <style>
    :root { --primary-rgb: 59 130 246; }
    /* Emergency Enter Button (Hidden by default, shown via JS if stuck) */
    #emergency-enter {
        display: none;
        margin-top: 20px;
        padding: 10px 20px;
        background: white;
        color: #1f2937;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        border: 2px solid #e5e7eb;
        font-size: 0.9rem;
        transition: opacity 0.2s;
    }
    #emergency-enter:hover { background: #f3f4f6; }
  </style>
</head>

<body>
  <div class="loading-screen active" id="loading-screen" aria-live="polite">
    <div class="loading-spinner"></div>
    <div class="loading-content">
      <h1 class="loading-title">Violin Mastery Quest</h1>
      <p class="loading-subtitle">Adaptive modules â€¢ Offline-ready</p>

      <div class="loading-progress">
        <div class="progress-bar">
          <div class="progress-fill" id="loading-progress-fill" style="--width: 0%"></div>
        </div>
      </div>

      <p class="loading-status" id="loading-status">Initializingâ€¦</p>
      <div class="engine-status" id="engine-status" aria-live="polite"></div>

      <button id="emergency-enter" onclick="document.getElementById('loading-screen').classList.remove('active')">
        Enter App Anyway
      </button>
    </div>
  </div>

  <div class="toast-container" id="toast-container"></div>

  <div class="diagnostic-overlay" id="diagnostic-overlay" style="display:none;">
    <div class="diagnostic-content">
      <h2>ðŸ”§ VMQ Diagnostic Mode</h2>
      <pre id="diagnostic-log" style="white-space:pre-wrap;"></pre>
      <button id="diagnostic-reload" class="btn btn-primary" type="button">Reload App</button>
    </div>
  </div>

  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script type="module">
    // Base-path derived from the directory that served THIS index.html
    const BASE_URL  = new URL('./', import.meta.url);
    const BASE_PATH = BASE_URL.pathname; 
    window.__VMQ_BASE_PATH__ = BASE_PATH;

    const startTime = performance.now();
    window.vmqMetrics = window.vmqMetrics || { loadTime: 0, engineInitTime: 0, mlWarmupTime: 0 };
    
    // Global health flag for Watchdog/Bootstrapper coordination
    window.vmqHealth = { enginesOk: false }; 

    const isDiagnosticMode =
      window.location.search.includes('vmq-diagnostics') ||
      window.location.search.includes('debug=true');

    const diagnosticLog = [];
    function logDiagnostic(category, message, data = null) {
      const timestamp = (performance.now() - startTime).toFixed(2);
      const line = `[${timestamp}ms] [${category}] ${message}${data ? ' ' + JSON.stringify(data) : ''}`;
      diagnosticLog.push(line);

      if (isDiagnosticMode) {
        console.log(`%cVMQ Diagnostics: ${line}`, 'color:#3b82f6;font-weight:bold;');
        const logEl = document.getElementById('diagnostic-log');
        if (logEl) logEl.textContent = diagnosticLog.join('\n');
      }
    }

    function showDiagnosticOverlay(extraError = null) {
      const overlay = document.getElementById('diagnostic-overlay');
      if (!overlay || !isDiagnosticMode) return;

      overlay.style.display = 'flex';
      const logEl = document.getElementById('diagnostic-log');
      if (logEl) {
        logEl.textContent =
          diagnosticLog.join('\n') +
          (extraError ? `\n\n${extraError?.stack || String(extraError)}` : '');
      }
    }

    window.addEventListener('error', (event) => {
      logDiagnostic('ERROR', event.message, { filename: event.filename, lineno: event.lineno, colno: event.colno });
      showDiagnosticOverlay(event.error || event);
    });

    window.addEventListener('unhandledrejection', (event) => {
      const reason = event?.reason;
      logDiagnostic('PROMISE', reason?.message || 'Unhandled rejection', reason ? { reason: String(reason) } : null);
      if (isDiagnosticMode) showDiagnosticOverlay(reason);
    });

    document.getElementById('diagnostic-reload')?.addEventListener('click', () => window.location.reload());

    function setLoadingStatus(text) {
      const el = document.getElementById('loading-status');
      if (el) el.textContent = text;
    }
    function setProgress(percent) {
      const fill = document.getElementById('loading-progress-fill');
      if (fill) fill.style.setProperty('--width', `${Math.max(0, Math.min(100, percent))}%`);
    }

    // Fail-open feature gating
    function checkFeature(featureName) {
      try {
        const features = window.VMQ?.FEATURES || window.VMQ?.features || {};
        return features?.[featureName]?.enabled !== false;
      } catch {
        return true;
      }
    }

    // Optional imports
    let ROUTE_TO_COMPONENT_FILE = Object.create(null);
    let normalizeRouteSlug = (s) => (s || '').toString().trim().toLowerCase();

    async function tryLoadRouteManifest() {
      try {
        const mod = await import(new URL('./js/config/routeManifest.js', BASE_URL).href);
        if (mod?.ROUTE_TO_COMPONENT_FILE) ROUTE_TO_COMPONENT_FILE = mod.ROUTE_TO_COMPONENT_FILE;
        if (typeof mod?.normalizeRouteSlug === 'function') normalizeRouteSlug = mod.normalizeRouteSlug;
        logDiagnostic('MANIFEST', 'routeManifest loaded');
      } catch (e) {
        logDiagnostic('MANIFEST', 'routeManifest missing/unavailable (continuing)', { err: String(e?.message || e) });
      }
    }

    // Engine health (degraded supported)
    const requiredEngines = [
      { name: 'audioEngine',       critical: true  },
      { name: 'gamification',      critical: true  },
      { name: 'sessionTracker',    critical: true  },
      { name: 'spacedRepetition',  critical: false },
      { name: 'analytics',         critical: false },
      { name: 'difficultyAdapter', critical: false }
    ];

    async function checkEngineHealth() {
      const statusEl = document.getElementById('engine-status');
      const status = {};
      let allCriticalOk = true;

      for (const e of requiredEngines) {
        try {
          const modUrl = new URL(`./js/engines/${e.name}.js`, BASE_URL).href;
          const mod = await import(modUrl);
          const ok = !!(mod && (mod.default || mod[e.name] || Object.keys(mod).length));
          status[e.name] = ok ? 'âœ…' : 'âŒ';
          if (!ok && e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: ${ok ? 'healthy' : 'failed'}`, { critical: e.critical });
        } catch (err) {
          status[e.name] = 'âŒ';
          if (e.critical) allCriticalOk = false;
          logDiagnostic('ENGINE', `${e.name}: failed to load`, { critical: e.critical, err: String(err?.message || err) });
        }
      }

      if (statusEl) {
        statusEl.innerHTML = Object.entries(status)
          .map(([name, icon]) => `<span class="engine-indicator">${icon} ${name}</span>`)
          .join('');
      }

      window.vmqHealth.enginesOk = allCriticalOk;
      return allCriticalOk;
    }

    // ML warmup (best-effort)
    async function warmupMLModels() {
      const wantAnalytics = checkFeature('analytics');
      const wantDA = checkFeature('difficultyAdapter');
      if (!wantAnalytics && !wantDA) return;

      const mlStart = performance.now();
      logDiagnostic('ML', 'Warming upâ€¦');

      try {
        const analyticsUrl  = new URL('./js/engines/analytics.js', BASE_URL).href;
        const difficultyUrl = new URL('./js/engines/difficultyAdapter.js', BASE_URL).href;

        const [analyticsMod, difficultyMod] = await Promise.allSettled([
          import(analyticsUrl),
          import(difficultyUrl)
        ]);

        if (analyticsMod.status === 'fulfilled' && typeof analyticsMod.value?.generateMLRecommendations === 'function') {
          await analyticsMod.value.generateMLRecommendations().catch(() => {});
          logDiagnostic('ML', 'Analytics warm');
        }

        if (difficultyMod.status === 'fulfilled' && typeof difficultyMod.value?.getAdaptiveConfig === 'function') {
          await difficultyMod.value.getAdaptiveConfig().catch(() => {});
          logDiagnostic('ML', 'Difficulty warm');
        }
      } catch (e) {
        logDiagnostic('ML', 'Warmup failed', { err: String(e?.message || e) });
      }

      window.vmqMetrics.mlWarmupTime = Math.round(performance.now() - mlStart);
      logDiagnostic('ML', `Warmup complete: ${window.vmqMetrics.mlWarmupTime}ms`);
    }

    // Prefetch (safe)
    function modulePreload(href) {
      if (!href) return;
      if (document.head.querySelector(`link[rel="modulepreload"][href="${href}"]`)) return;
      const link = document.createElement('link');
      link.rel = 'modulepreload';
      link.href = href;
      document.head.appendChild(link);
    }

    function resolveComponentHref(routeOrId) {
      if (!routeOrId) return null;
      const raw = String(routeOrId).replace(/^#/, '').split('?')[0].trim();
      if (!raw) return null;
      const key = normalizeRouteSlug(raw);
      const file = ROUTE_TO_COMPONENT_FILE?.[key];
      return file ? new URL(`./js/components/${file}`, BASE_URL).href : null;
    }

    async function prefetchUserModules() {
      let level = 'beginner';
      try {
        const raw = localStorage.getItem('vmq-profile') || localStorage.getItem('vmq.profile');
        const profile = raw ? JSON.parse(raw) : null;
        if (profile?.level) level = profile.level;
      } catch {}

      const modulesToPrefetch = {
        beginner:      ['intervals', 'keys', 'rhythm'],
        intermediate:  ['bieler', 'scales', 'fingerboard'],
        advanced:      ['bieler', 'scales', 'flashcards']
      };

      const list = modulesToPrefetch[level] || modulesToPrefetch.beginner;
      list.forEach((id) => modulePreload(resolveComponentHref(id)));
      logDiagnostic('PREFETCH', `modulepreload(${level})`, list);
    }

    // Service Worker registration
    async function registerServiceWorker() {
      if (window.__VMQ_SW_REGISTERED__) return;
      if (!checkFeature('pwaOffline') || !('serviceWorker' in navigator)) return;

      try {
        const scopeUrl = BASE_URL.href;
        const existing = await navigator.serviceWorker.getRegistration(scopeUrl);
        let registration = existing;

        if (!registration) {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = 'index.html';
          const swUrl = new URL('./sw.js', BASE_URL).href;
          registration = await navigator.serviceWorker.register(swUrl, { scope: BASE_PATH, updateViaCache: 'none' });
          logDiagnostic('SW', `Registered`, { scope: registration.scope });
        } else {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = 'existing';
          logDiagnostic('SW', `Using existing`, { scope: registration.scope });
        }

        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              window.dispatchEvent(new CustomEvent('vmq-update-available', {
                detail: { version: '3.0.4', cacheBust: Date.now() }
              }));
            }
          });
        });
      } catch (err) {
        window.__VMQ_SW_REGISTERED__ = false;
        logDiagnostic('SW', 'Registration failed', { err: String(err?.message || err) });
      }
    }

    // Keep shell visible until React confirms mount
    function waitForReactMount({ timeoutMs = 12000 } = {}) {
      return new Promise((resolve) => {
        let done = false;
        const finish = (why) => { if (!done) { done = true; resolve(why); } };
        const onMounted = () => finish('vmq-app-mounted');
        window.addEventListener('vmq-app-mounted', onMounted, { once: true });
        setTimeout(() => finish('timeout'), timeoutMs);
      });
    }

    // Bootstrap sequence
    async function bootstrap() {
      setProgress(10);
      setLoadingStatus('Preparingâ€¦');

      await tryLoadRouteManifest();
      setProgress(20);

      setLoadingStatus('Warming upâ€¦');
      await warmupMLModels();
      setProgress(40);

      setLoadingStatus('Checking enginesâ€¦');
      const criticalOk = await checkEngineHealth();
      if (!criticalOk) setLoadingStatus('Some features unavailable, continuingâ€¦');
      setProgress(60);

      setLoadingStatus('Prefetchingâ€¦');
      await prefetchUserModules();
      setProgress(75);

      setLoadingStatus('Enabling offlineâ€¦');
      await registerServiceWorker();
      setProgress(90);

      window.vmqMetrics.engineInitTime = Math.round(performance.now() - startTime);
      setProgress(100);
      logDiagnostic('BOOTSTRAP', 'Complete', window.vmqMetrics);
    }

    // Run bootstrap
    bootstrap().then(async () => {
      const why = await waitForReactMount({ timeoutMs: 12000 });

      if (why === 'timeout') {
        // [FIXED] Smart Timeout Handling
        logDiagnostic('BOOTSTRAP', 'React mount timeout');
        
        if (window.vmqHealth.enginesOk) {
            logDiagnostic('BOOTSTRAP', 'Engines healthy, forcing shell hide');
            document.getElementById('loading-screen')?.classList.remove('active');
        } else {
            // Only show stuck message/button if engines actually failed or are unknown
            setLoadingStatus('Still loadingâ€¦');
            const enterBtn = document.getElementById('emergency-enter');
            if(enterBtn) enterBtn.style.display = 'block';
            if (isDiagnosticMode) showDiagnosticOverlay(null);
        }
        return;
      }

      // React confirmed mount
      document.getElementById('loading-screen')?.classList.remove('active');
      window.dispatchEvent(new CustomEvent('vmq-ready', { detail: { metrics: window.vmqMetrics, diagnosticLog } }));
    }).catch((err) => {
      logDiagnostic('BOOTSTRAP', 'Fatal error', { err: String(err?.message || err) });
      showDiagnosticOverlay(err);
      setLoadingStatus('Error loading VMQ. Enable diagnostics for details.');
    });
  </script>

  <script type="module" src="./js/App.js"></script>

  <script>
    (function() {
        console.log("VMQ Watchdog: Active and monitoring...");

        const checkInterval = setInterval(() => {
            const loadingScreen = document.getElementById('loading-screen');
            
            // If loader is already gone, stop watching
            if (!loadingScreen || !loadingScreen.classList.contains('active') || loadingScreen.style.display === 'none') {
                clearInterval(checkInterval);
                return;
            }

            // [FIXED] Scan for 'âœ…' symbols (Standard index.html output) OR checkboxes (App.js output)
            // This ensures it works regardless of which subsystem renders the status
            const requiredModules = ['audioEngine', 'gamification', 'sessionTracker'];
            const engineStatusDiv = document.getElementById('engine-status');
            const statusText = engineStatusDiv ? engineStatusDiv.innerText : "";

            let readyCount = 0;
            requiredModules.forEach(mod => {
                // Check 1: Emoji presence in the text block
                const emojiReady = statusText.includes(`âœ… ${mod}`);
                
                // Check 2: Checkbox presence (legacy/App.js rendered)
                const checkbox = document.getElementById(mod) || document.querySelector(`[name="${mod}"]`);
                const checkboxReady = checkbox && checkbox.checked;

                if (emojiReady || checkboxReady) {
                    readyCount++;
                }
            });

            // Trigger if critical modules are ready but screen is still up (stuck state)
            const isStuck = (readyCount === requiredModules.length);
            
            if (isStuck) {
                console.warn("VMQ Watchdog: Hang detected (Modules ready). Forcing start...");

                // A. Force Audio Unlock (Safe Resume for Violin App)
                // This ensures we don't break audio permission policies when forcing the screen open
                const unlockAudio = () => {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (window.audioCtx && window.audioCtx.state === 'suspended') {
                        window.audioCtx.resume();
                    }
                    document.removeEventListener('click', unlockAudio);
                    document.removeEventListener('touchstart', unlockAudio);
                };
                document.addEventListener('click', unlockAudio);
                document.addEventListener('touchstart', unlockAudio);

                // B. Remove the Loading Screen Gracefully
                loadingScreen.style.transition = "opacity 0.5s ease";
                loadingScreen.style.opacity = "0";
                
                clearInterval(checkInterval);

                setTimeout(() => {
                    loadingScreen.classList.remove('active');
                    loadingScreen.style.opacity = "1"; // Reset for next reload
                    // Trigger resize to fix any canvas/WebGL rendering issues caused by hidden state
                    window.dispatchEvent(new Event('resize'));
                }, 500);
            }
        }, 1000); 
    })();
  </script>
</body>
</html>
