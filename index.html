<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ðŸŽ¯ PERFORMANCE (Critical Meta) -->
  <meta charset="UTF-8">
  <!-- Accessibility-friendly: allow zoom; keep viewport-fit for iOS safe areas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#3b82f6">
  <meta name="color-scheme" content="light dark">

  <!-- ðŸŽ¯ SECURITY (CSP) -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://unpkg.com 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://unpkg.com; img-src 'self' data:; font-src 'self'; media-src 'self'; object-src 'none'; base-uri 'self'; frame-ancestors 'none';">

  <!-- ðŸŽ¯ PWA / iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Violin Mastery Quest">
  <meta name="application-name" content="VMQ">

  <!-- ðŸŽ¯ SEO + Social -->
  <meta name="description" content="Violin Mastery Quest v3.0 - adaptive violin training: intervals, fingerboard, scales, rhythm, SM-2, AI coach">
  <title>Violin Mastery Quest</title>

  <!-- ðŸŽ¯ Open Graph -->
  <meta property="og:title" content="Violin Mastery Quest">
  <meta property="og:description" content="Adaptive violin training: Bieler Method + spaced repetition + AI coach">
  <meta property="og:image" content="./icons/icon-512.png">
  <meta property="og:type" content="website">

  <!-- ðŸŽ¯ PWA Manifest -->
  <link rel="manifest" href="./manifest.json">

  <!-- ðŸŽ¯ Icons (consistent sizes: 16, 32, 180, 192, 512) -->
  <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512.png">
  <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png">

  <!-- NOTE: Removed Safari mask-icon because it must be SVG (PNG was invalid). -->

  <!-- ðŸŽ¯ PERFORMANCE (Preconnect + DNS) -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="dns-prefetch" href="https://unpkg.com">

  <!-- ðŸŽ¯ Critical CSS (Above-the-fold) -->
  <link rel="preload" href="./css/base.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="./css/base.css"></noscript>
  <link rel="preload" href="./css/components.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="./css/components.css"></noscript>
  <link rel="preload" href="./css/themes.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="./css/themes.css"></noscript>
  <link rel="preload" href="./css/animations.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="./css/animations.css"></noscript>

  <!-- ðŸŽ¯ Core Web Vitals -->
  <link rel="preload" href="./js/App.js" as="script">
</head>

<body>
  <!-- ðŸŽ¯ APP ROOT -->
  <div id="root">
    <!-- ðŸš€ Loading Screen (Progressive Enhancement) -->
    <div class="loading-screen active" id="loading-screen">
      <div class="loading-spinner"></div>
      <div class="loading-content">
        <h1 class="loading-title">Violin Mastery Quest</h1>
        <p class="loading-subtitle">Adaptive modules â€¢ Offline-ready</p>
        <div class="loading-progress">
          <div class="progress-bar">
            <div class="progress-fill" style="--width: 0%"></div>
          </div>
        </div>
        <p class="loading-status" id="loading-status">Initializing...</p>
        <div class="engine-status" id="engine-status" aria-live="polite"></div>
      </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- App Content (React takeover) -->
    <div class="app-wrapper" id="app-content" style="display: none;">
      <!-- React renders here -->
    </div>

    <!-- Diagnostic Overlay -->
    <div class="diagnostic-overlay" id="diagnostic-overlay" style="display: none;">
      <div class="diagnostic-content">
        <h2>ðŸ”§ VMQ Diagnostic Mode</h2>
        <pre id="diagnostic-log"></pre>
        <button id="diagnostic-reload" class="btn btn-primary">Reload App</button>
      </div>
    </div>
  </div>

  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- VMQ BOOTSTRAP (Shell-level; keep lightweight) -->
  <script type="module">
    const startTime = performance.now();
    window.vmqMetrics = window.vmqMetrics || {
      fcp: 0, fid: 0, cls: 0,
      loadTime: 0, engineInitTime: 0, mlWarmupTime: 0
    };

    const isDiagnosticMode =
      window.location.search.includes('vmq-diagnostics') ||
      window.location.search.includes('debug=true');

    const diagnosticLog = [];
    function logDiagnostic(category, message, data = null) {
      const timestamp = (performance.now() - startTime).toFixed(2);
      const logEntry = `[${timestamp}ms] [${category}] ${message}${data ? ' ' + JSON.stringify(data) : ''}`;
      diagnosticLog.push(logEntry);

      if (isDiagnosticMode) {
        console.log(`%cVMQ Diagnostics: ${logEntry}`, 'color: #3b82f6; font-weight: bold;');
        const logEl = document.getElementById('diagnostic-log');
        if (logEl) logEl.textContent = diagnosticLog.join('\n');
      }
    }

    // Shell error boundary
    window.addEventListener('error', (event) => {
      logDiagnostic('ERROR', event.message, { filename: event.filename, lineno: event.lineno });
      if (String(event.message).includes('ENGINE') || String(event.message).includes('MODULE')) {
        const overlay = document.getElementById('diagnostic-overlay');
        const appContent = document.getElementById('app-content');
        if (overlay && appContent) {
          appContent.style.display = 'none';
          overlay.style.display = 'flex';
        }
      }
    });
    window.addEventListener('unhandledrejection', (event) => {
      logDiagnostic('PROMISE', event.reason?.message || 'Unhandled rejection', event.reason);
    });

    // Feature-flag check (fail-open if VMQ not loaded yet)
    function checkFeature(featureName) {
      try {
        const features = window.VMQ?.FEATURES || window.VMQ?.features || {};
        const isEnabled = features[featureName]?.enabled !== false;
        logDiagnostic('FEATURE', `${featureName}: ${isEnabled ? 'âœ…' : 'âŒ'}`);
        return isEnabled;
      } catch (e) {
        logDiagnostic('FEATURE', `${featureName}: âš ï¸ check failed`, e);
        return true;
      }
    }

    const requiredEngines = [
      'audioEngine',
      'spacedRepetition',
      'gamification',
      'analytics',
      'coachEngine',
      'pedagogyEngine',
      'sessionTracker',
      'difficultyAdapter'
    ];

    async function checkEngineHealth() {
      const statusEl = document.getElementById('engine-status');
      const status = {};

      for (const engine of requiredEngines) {
        try {
          const module = await import(`./js/engines/${engine}.js`);
          const isHealthy = !!(module && (module.default || module[engine]));
          status[engine] = isHealthy ? 'âœ…' : 'âŒ';
          logDiagnostic('ENGINE', `${engine}: ${isHealthy ? 'healthy' : 'failed'}`);
        } catch (e) {
          status[engine] = 'âŒ';
          logDiagnostic('ENGINE', `${engine}: failed to load`, e);
        }
      }

      if (statusEl) {
        statusEl.innerHTML = Object.entries(status)
          .map(([name, icon]) => `<span class="engine-indicator">${icon} ${name}</span>`)
          .join('');
      }

      return Object.values(status).every(s => s === 'âœ…');
    }

    async function warmupMLModels() {
      if (!checkFeature('analytics') && !checkFeature('difficultyAdapter')) {
        logDiagnostic('ML', 'ML features disabled, skipping warmup');
        return;
      }

      const mlStart = performance.now();
      logDiagnostic('ML', 'Warming up models...');

      try {
        const [analyticsMod, difficultyMod] = await Promise.all([
          import('./js/engines/analytics.js'),
          import('./js/engines/difficultyAdapter.js')
        ]);

        if (analyticsMod.analyzePerformance) {
          await analyticsMod.analyzePerformance('week', { includePredictions: false, includePatterns: true });
          logDiagnostic('ML', 'Analytics model ready');
        }
        if (difficultyMod.getUserLevel) {
          await difficultyMod.getUserLevel();
          logDiagnostic('ML', 'Difficulty model ready');
        }
      } catch (e) {
        logDiagnostic('ML', 'Warmup failed', e);
      }

      window.vmqMetrics.mlWarmupTime = Math.round(performance.now() - mlStart);
      logDiagnostic('ML', `Warmup complete: ${window.vmqMetrics.mlWarmupTime}ms`);
    }
    
    // =========================================================
    // âœ… Component prefetch resolver (ROUTE_TO_COMPONENT_FILE logic)
    // Keeps bootstrap lightweight, avoids dead prefetch paths.
    // =========================================================
    const ROUTE_TO_COMPONENT_FILE = {
      // Core / common
      'menu': 'Menu.js',
      'dashboard': 'Dashboard.js',
      'coach': 'Coach.js',
      'settings': 'Settings.js',
      'analytics': 'Analytics.js',
      'achievements': 'Achievements.js',
      'dailygoals': 'DailyGoals.js',

      // Theory / drills
      'intervals': 'Intervals.js',
      'interval-ear': 'IntervalEar.js',
      'interval-sprint': 'IntervalSprint.js',
      'keys': 'Keys.js',
      'key-tester': 'KeyTester.js',
      'rhythm': 'Rhythm.js',
      'rhythm-drills': 'RhythmDrills.js',
      'tempotrainer': 'TempoTrainer.js',

      // Technique
      'bieler': 'Bieler.js',
      'bielerlab': 'BielerLab.js',
      'fingerboard': 'Fingerboard.js',
      'notelocator': 'NoteLocator.js',

      // âœ… Known mismatch in your note: â€œscalesâ€ often actually means ScalesLab
      'scales': 'ScalesLab.js',
      'scaleslab': 'ScalesLab.js',

      // Speed / misc
      'speeddrill': 'SpeedDrill.js',
      'practicejournal': 'PracticeJournal.js',
      'datamanager': 'DataManager.js',
      'spaced-rep': 'SpacedRep.js',
      'flashcards': 'Flashcards.js'
    };

    function _toPascalCase(route) {
      return String(route)
        .split(/[-_]/g)
        .filter(Boolean)
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join('');
    }

    function resolveComponentHref(routeOrId) {
      if (!routeOrId) return null;

      // Normalize (strip hash/query)
      const raw = String(routeOrId).replace(/^#/, '').split('?')[0].trim();
      if (!raw) return null;

      const key = raw.toLowerCase();
      const mapped = ROUTE_TO_COMPONENT_FILE[key];
      if (mapped) return `./js/components/${mapped}`;

      // Fallback 1: exact filename match (route.js)
      // This supports modules that truly are lowercase route names.
      if (/^[a-z0-9_-]+$/i.test(raw)) {
        return `./js/components/${raw}.js`;
      }

      // Fallback 2: PascalCase guess (IntervalEar.js, ScalesLab.js, etc.)
      return `./js/components/${_toPascalCase(key)}.js`;
    }

    function prefetchScript(href) {
      if (!href) return;

      // Avoid duplicates
      if (document.head.querySelector(`link[rel="prefetch"][href="${href}"]`)) return;

      const link = document.createElement('link');
      link.rel = 'prefetch';
      link.as = 'script';
      link.href = href;
      document.head.appendChild(link);
    }

    async function prefetchUserModules() {
      try {
        // This path now exists (wrapper file) and is compatible with existing code.
        const storage = await import('./js/engines/storage.js');
        const profile = await storage.loadJSON('vmq-profile', { level: 'beginner' });

        // Keep your existing intent, but ensure routes map to *real* component files.
        const modulesToPrefetch = {
          beginner: ['intervals', 'keys', 'rhythm'],
          intermediate: ['bieler', 'scales', 'fingerboard'],
          advanced: ['bieler', 'scales', 'speeddrill']
        };

        const modules = modulesToPrefetch[profile.level] || modulesToPrefetch.beginner;

        for (const routeOrId of modules) {
          const href = resolveComponentHref(routeOrId);
          prefetchScript(href);
        }

        logDiagnostic('PREFETCH', `Prefetched modules for ${profile.level}`, modules);
      } catch (e) {
        logDiagnostic('PREFETCH', 'Failed', e);
      }
    }

    // PWA install prompt
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      document.documentElement.style.setProperty('--pwa-available', 'true');
      logDiagnostic('PWA', 'Install prompt available');
    });

    // Service Worker registration (SINGLE OWNER: index.html)
    async function registerServiceWorker() {
      if (window.__VMQ_SW_REGISTERED__) {
        logDiagnostic('SW', 'Already registered (guard flag set)');
        return;
      }
      if (!checkFeature('pwaOffline') || !('serviceWorker' in navigator)) {
        logDiagnostic('SW', 'Service Worker disabled or not supported');
        return;
      }

      try {
        // Prefer an existing registration if present
        const existing = await navigator.serviceWorker.getRegistration('./');
        let registration = existing;

        if (!registration) {
          window.__VMQ_SW_REGISTERED__ = true; // guard early to avoid races with other modules
          window.__VMQ_SW_OWNER__ = 'index.html';

          const swUrl = './sw.js';
          registration = await navigator.serviceWorker.register(swUrl, {
            scope: './',
            updateViaCache: 'none'
          });
          logDiagnostic('SW', `Registered: ${registration.scope}`);
        } else {
          window.__VMQ_SW_REGISTERED__ = true;
          window.__VMQ_SW_OWNER__ = window.__VMQ_SW_OWNER__ || 'existing';
          logDiagnostic('SW', `Using existing registration: ${registration.scope}`);
        }

        // Update detection â†’ toast event
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          newWorker?.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              logDiagnostic('SW', 'Update available');
              document.documentElement.style.setProperty('--sw-update', 'true');
              window.dispatchEvent(new CustomEvent('vmq-update-available', {
                detail: { version: '3.0', cacheBust: Date.now() }
              }));
            }
          });
        });

        // âœ… Background Sync tag names aligned to sw.js:
        // sw.js listens for 'sync-analytics' and 'sync-sm2'
        if (registration.sync) {
          try {
            await registration.sync.register('sync-analytics');
            logDiagnostic('SYNC', 'Background sync registered: sync-analytics');
          } catch (e) {
            logDiagnostic('SYNC', 'Background sync failed: sync-analytics', e);
          }

          try {
            await registration.sync.register('sync-sm2');
            logDiagnostic('SYNC', 'Background sync registered: sync-sm2');
          } catch (e) {
            logDiagnostic('SYNC', 'Background sync failed: sync-sm2', e);
          }
        } else {
          logDiagnostic('SYNC', 'Background Sync not supported');
        }

        // âœ… Periodic Background Sync tag aligned to sw.js: 'check-due-items'
        if (registration.periodicSync) {
          try {
            await registration.periodicSync.register('check-due-items', {
              minInterval: 30 * 60 * 1000 // 30 minutes
            });
            logDiagnostic('SYNC', 'Periodic sync registered: check-due-items');
          } catch (e) {
            logDiagnostic('SYNC', 'Periodic sync failed: check-due-items', e);
          }
        }

      } catch (err) {
        window.__VMQ_SW_REGISTERED__ = false;
        logDiagnostic('SW', 'Registration failed', err);
      }
    }

    async function checkStorageQuota() {
      try {
        if ('storage' in navigator && navigator.storage.estimate) {
          const estimate = await navigator.storage.estimate();
          const usedPercent = Math.round((estimate.usage / estimate.quota) * 100);
          logDiagnostic('STORAGE', `Quota: ${usedPercent}% used`);

          if (usedPercent > 80) {
            const storage = await import('./js/engines/storage.js');
            if (storage.autoPrune) {
              await storage.autoPrune();
              logDiagnostic('STORAGE', 'Auto-prune triggered');
            }
          }
        }
      } catch (e) {
        logDiagnostic('STORAGE', 'Quota check failed', e);
      }
    }

    function getConnectionStatus() {
      const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      if (!connection) return { type: 'unknown', downlink: 0, saveData: false };
      return {
        type: connection.effectiveType || 'unknown',
        downlink: connection.downlink || 0,
        saveData: connection.saveData || false
      };
    }

    function adaptLoadingToConnection() {
      const conn = getConnectionStatus();
      const statusEl = document.getElementById('loading-status');

      if (conn.saveData) {
        logDiagnostic('CONNECTION', 'Data saver enabled, reducing features');
        if (statusEl) statusEl.textContent = 'Optimizing for data saver...';
      } else if (conn.type === '2g' || conn.downlink < 1) {
        logDiagnostic('CONNECTION', 'Slow connection detected');
        if (statusEl) statusEl.textContent = 'Slow connection, loading essentials...';
      }
    }

    async function adaptToBattery() {
      try {
        if (!navigator.getBattery) return;
        const battery = await navigator.getBattery();
        if (battery.level < 0.2 && !battery.charging) {
          logDiagnostic('BATTERY', 'Low battery, reducing animations');
          document.documentElement.style.setProperty('--reduced-motion', 'true');
        }
      } catch (e) {
        logDiagnostic('BATTERY', 'API not available', e);
      }
    }

    function setupCrossTabSync() {
      if (!('BroadcastChannel' in window)) return;
      const channel = new BroadcastChannel('vmq-sync');

      channel.addEventListener('message', (event) => {
        if (event.data?.type === 'settings-changed') {
          logDiagnostic('SYNC', 'Settings changed in another tab');
          window.location.reload();
        }
      });

      window.addEventListener('beforeunload', () => {
        channel.postMessage({ type: 'tab-closing', timestamp: Date.now() });
      });

      logDiagnostic('SYNC', 'Cross-tab sync enabled');
    }

    async function setupEngagement() {
      try {
        const storage = await import('./js/engines/storage.js');
        const sessions = await storage.loadJSON('vmq-practice-sessions', []);

        if (sessions.length === 3 && 'Notification' in window && Notification.permission === 'default') {
          setTimeout(() => {
            Notification.requestPermission().then(permission => {
              logDiagnostic('ENGAGEMENT', `Notification permission: ${permission}`);
              if (permission === 'granted') {
                navigator.serviceWorker.controller?.postMessage({
                  type: 'SCHEDULE_REMINDER',
                  delay: 24 * 60 * 60 * 1000
                });
              }
            });
          }, 5000);
        }
      } catch (e) {
        logDiagnostic('ENGAGEMENT', 'Setup failed', e);
      }
    }

    function announceToScreenReader(message) {
      const announcer = document.createElement('div');
      announcer.setAttribute('role', 'status');
      announcer.setAttribute('aria-live', 'polite');
      announcer.style.position = 'absolute';
      announcer.style.left = '-10000px';
      announcer.textContent = message;
      document.body.appendChild(announcer);
      setTimeout(() => announcer.remove(), 1000);
    }

    async function bootstrap() {
      logDiagnostic('BOOTSTRAP', 'Starting VMQ bootstrap');

      adaptLoadingToConnection();
      await adaptToBattery();
      await checkStorageQuota();
      await warmupMLModels();

      const enginesHealthy = await checkEngineHealth();
      if (!enginesHealthy) {
        logDiagnostic('BOOTSTRAP', 'âš ï¸ Some engines failed health check');
        const el = document.getElementById('loading-status');
        if (el) el.textContent = 'Some features unavailable, continuing...';
      }

      await prefetchUserModules();
      await registerServiceWorker();
      setupCrossTabSync();
      await setupEngagement();

      window.vmqMetrics.engineInitTime = Math.round(performance.now() - startTime);
      logDiagnostic('BOOTSTRAP', `Complete: ${window.vmqMetrics.engineInitTime}ms`);
    }

    bootstrap().then(() => {
      const loadingScreen = document.getElementById('loading-screen');
      const appContent = document.getElementById('app-content');
      const progressFill = loadingScreen?.querySelector('.progress-fill');

      if (progressFill) progressFill.style.setProperty('--width', '100%');
      announceToScreenReader('Violin Mastery Quest is ready');

      setTimeout(() => {
        if (loadingScreen) loadingScreen.classList.remove('active');
        if (appContent) appContent.style.display = 'flex';

        window.dispatchEvent(new CustomEvent('vmq-ready', {
          detail: { metrics: window.vmqMetrics, diagnosticLog }
        }));
      }, 500);
    }).catch(err => {
      logDiagnostic('BOOTSTRAP', 'Fatal error during bootstrap', err);

      const overlay = document.getElementById('diagnostic-overlay');
      const appContent = document.getElementById('app-content');
      if (overlay && appContent) {
        appContent.style.display = 'none';
        overlay.style.display = 'flex';
        const logEl = document.getElementById('diagnostic-log');
        if (logEl) logEl.textContent = diagnosticLog.join('\n') + '\n\n' + (err?.stack || String(err));
      }
    });

    document.getElementById('diagnostic-reload')?.addEventListener('click', () => window.location.reload());
  </script>

  <!-- VMQ APP ENTRY -->
  <script type="module" src="./js/App.js"></script>
</body>
</html>
